# 検索結果ハイライト・D&Dビジュアルフィードバック 設計書

## 目次

1. [検索結果ハイライト](#1-検索結果ハイライト)
2. [ドラッグ&ドロップビジュアルフィードバック](#2-ドラッグドロップビジュアルフィードバック)

---

## 1. 検索結果ハイライト

### 1.1 概要

検索語句に一致する部分をファイル名・タグ・メタデータ内で視覚的に強調表示し、検索結果の視認性を向上させる。

### 1.2 ハイライト対象

#### 1.2.1 ファイル名

```txt
検索: "manga"

┌─────────────────────────┐
│ 📚 <manga>_vol1.zip     │ ← "manga"がハイライト
│ 50ページ 12.3MB          │
│ 🏷️漫画 🏷️完結           │
└─────────────────────────┘

┌─────────────────────────┐
│ 🎬 video_<manga>.mp4    │
│ 45:23 523MB             │
│ 🏷️動画                  │
└─────────────────────────┘
```

#### 1.2.2 タグ名

```txt
検索: "イラスト"

┌─────────────────────────┐
│ 📚 artbook_001.zip      │
│ 120ページ 45.6MB         │
│ 🏷️<イラスト> 🏷️高解像度 │ ← "イラスト"がハイライト
└─────────────────────────┘
```

#### 1.2.3 メタデータ（詳細表示時）

```txt
検索: "Canon"

ファイル名: photo_001.jpg
EXIF情報:
  メーカー: <Canon>        ← ハイライト
  モデル: <Canon> EOS 5D   ← ハイライト
  撮影日時: 2024-10-01
```

### 1.3 ハイライトスタイル

#### 1.3.1 基本ハイライト

```typescript
<span className="highlight-match">manga</span>
```

**CSS:**

```css
.highlight-match {
  background-color: rgba(255, 235, 59, 0.4); /* 黄色半透明 */
  color: inherit;
  font-weight: 600;
  padding: 2px 0;
  border-radius: 2px;
}

/* ダークモード */
.dark .highlight-match {
  background-color: rgba(255, 193, 7, 0.3);
}
```

#### 1.3.2 現在フォーカス中のマッチ

```css
.highlight-match.current {
  background-color: rgba(255, 152, 0, 0.6);
  outline: 2px solid var(--primary-main);
}
```

#### 1.3.3 複数マッチの色分け

```typescript
// 複数検索語句の場合は色を変える
<span className="highlight-match color-1">manga</span>
<span className="highlight-match color-2">comic</span>
```

```css
.highlight-match.color-1 {
  background-color: rgba(255, 235, 59, 0.4); /* 黄色 */
}

.highlight-match.color-2 {
  background-color: rgba(76, 175, 80, 0.4); /* 緑色 */
}

.highlight-match.color-3 {
  background-color: rgba(33, 150, 243, 0.4); /* 青色 */
}
```

### 1.4 実装

#### 1.4.1 ハイライト関数

```typescript
/**
 * テキスト内の検索語句をハイライト
 */
const highlightText = (
  text: string,
  searchTerms: string[],
  currentMatchIndex?: number
): React.ReactNode => {
  if (searchTerms.length === 0) return text;

  // エスケープ処理
  const escapedTerms = searchTerms.map(term =>
    term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  );

  // 正規表現作成（大文字小文字区別なし）
  const pattern = new RegExp(`(${escapedTerms.join('|')})`, 'gi');
  const parts = text.split(pattern);

  let matchIndex = 0;

  return parts.map((part, index) => {
    const isMatch = searchTerms.some(term =>
      part.toLowerCase() === term.toLowerCase()
    );

    if (isMatch) {
      const colorIndex = searchTerms.findIndex(term =>
        part.toLowerCase() === term.toLowerCase()
      );
      const isCurrent = currentMatchIndex === matchIndex;
      matchIndex++;

      return (
        <span
          key={index}
          className={`highlight-match color-${colorIndex + 1} ${isCurrent ? 'current' : ''}`}
        >
          {part}
        </span>
      );
    }

    return part;
  });
};
```

#### 1.4.2 使用例

```typescript
const FileCard: React.FC<{
  file: FileInfo;
  searchTerms: string[];
}> = ({ file, searchTerms }) => {
  return (
    <div className="file-card">
      <div className="file-name">
        {highlightText(file.file_name, searchTerms)}
      </div>
      
      <div className="file-tags">
        {file.tags.map(tag => (
          <span key={tag.id} className="tag-chip">
            {highlightText(tag.tag_name, searchTerms)}
          </span>
        ))}
      </div>
    </div>
  );
};
```

#### 1.4.3 マッチナビゲーション

```typescript
const SearchMatchNavigation: React.FC<{
  totalMatches: number;
  currentMatch: number;
  onNext: () => void;
  onPrev: () => void;
}> = ({ totalMatches, currentMatch, onNext, onPrev }) => {
  if (totalMatches === 0) return null;

  return (
    <div className="match-navigation">
      <span className="match-count">
        {currentMatch + 1} / {totalMatches} 件
      </span>
      <button
        onClick={onPrev}
        disabled={currentMatch === 0}
        aria-label="前のマッチ"
      >
        ▲
      </button>
      <button
        onClick={onNext}
        disabled={currentMatch === totalMatches - 1}
        aria-label="次のマッチ"
      >
        ▼
      </button>
    </div>
  );
};
```

### 1.5 パフォーマンス最適化

#### 1.5.1 メモ化

```typescript
const MemoizedFileCard = React.memo<FileCardProps>(
  ({ file, searchTerms }) => {
    const highlightedName = useMemo(
      () => highlightText(file.file_name, searchTerms),
      [file.file_name, searchTerms]
    );

    return (
      <div className="file-card">
        <div className="file-name">{highlightedName}</div>
      </div>
    );
  },
  (prev, next) => {
    return (
      prev.file.id === next.file.id &&
      prev.searchTerms.join(',') === next.searchTerms.join(',')
    );
  }
);
```

#### 1.5.2 仮想スクロールとの連携

```typescript
import { FixedSizeList } from 'react-window';

const VirtualizedSearchResults: React.FC<{
  files: FileInfo[];
  searchTerms: string[];
}> = ({ files, searchTerms }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <MemoizedFileCard
        file={files[index]}
        searchTerms={searchTerms}
      />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={files.length}
      itemSize={120}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
};
```

---

## 2. ドラッグ&ドロップビジュアルフィードバック

### 2.1 概要

ファイルやタグのドラッグ&ドロップ操作時に、視覚的なフィードバックを提供してユーザーに現在の状態を明確に伝える。

### 2.2 ドラッグ状態の種類

#### 2.2.1 ドラッグ開始

```txt
┌─────────────────────────┐
│ 📚 manga_vol1.zip       │ ← 元の位置（半透明）
└─────────────────────────┘

  ↓ カーソルに追従

┌─────────────────────────┐
│ 📚 manga_vol1.zip       │ ← ドラッグゴースト
│ + 2件のファイル          │
└─────────────────────────┘
```

#### 2.2.2 有効なドロップターゲット上

```txt
┌───────────────────────────┐
│ ☑ 🔵 漫画 (87)      [⭐]  │ ← 青い背景、点線ボーダー
│   ドロップしてタグを追加   │ ← ヒントテキスト表示
└───────────────────────────┘
```

#### 2.2.3 無効なドロップターゲット上

```txt
┌───────────────────────────┐
│ ☐ 🔴 動画 (24)            │ ← 赤い背景、禁止アイコン
│   このタグには追加できません│
└───────────────────────────┘
```

#### 2.2.4 ドロップ完了アニメーション

```txt
ファイル → タグ

[ファイル] ━━━━━━━> [タグ]
           パーティクル効果
           
[タグ] ✓ 追加完了
  ↓
 拡大→縮小アニメーション
```

### 2.3 ドラッグゴーストのカスタマイズ

#### 2.3.1 単一ファイル

```txt
┌─────────────────────────────┐
│ 📚 manga_vol1.zip           │
│ 50ページ | 12.3MB            │
└─────────────────────────────┘
```

#### 2.3.2 複数ファイル

```txt
┌─────────────────────────────┐
│ 📚 manga_vol1.zip           │
│ + 4件のファイル              │
│ 合計: 67.8MB                 │
└─────────────────────────────┘
```

#### 2.3.3 タグドラッグ

```txt
┌─────────────────────┐
│ 🔵 漫画 (87)        │
└─────────────────────┘
```

### 2.4 実装

#### 2.4.1 ドラッグ開始

```typescript
const useDragAndDrop = () => {
  const [isDragging, setIsDragging] = useState(false);
  const [draggedItems, setDraggedItems] = useState<FileInfo[]>([]);
  const [dropTarget, setDropTarget] = useState<string | null>(null);

  const handleDragStart = (
    e: React.DragEvent,
    items: FileInfo[]
  ) => {
    setIsDragging(true);
    setDraggedItems(items);

    // データ転送設定
    e.dataTransfer.effectAllowed = 'copy';
    e.dataTransfer.setData('application/json', JSON.stringify({
      type: 'files',
      items: items.map(item => item.id),
    }));

    // カスタムドラッグイメージ
    const dragGhost = createDragGhost(items);
    document.body.appendChild(dragGhost);
    e.dataTransfer.setDragImage(dragGhost, 20, 20);

    // クリーンアップ
    setTimeout(() => {
      document.body.removeChild(dragGhost);
    }, 0);
  };

  const handleDragEnd = () => {
    setIsDragging(false);
    setDraggedItems([]);
    setDropTarget(null);
  };

  return {
    isDragging,
    draggedItems,
    dropTarget,
    handleDragStart,
    handleDragEnd,
    setDropTarget,
  };
};

const createDragGhost = (items: FileInfo[]): HTMLElement => {
  const ghost = document.createElement('div');
  ghost.className = 'drag-ghost';
  
  if (items.length === 1) {
    ghost.innerHTML = `
      <div class="drag-ghost-content">
        <span class="file-icon">${getFileIcon(items[0])}</span>
        <span class="file-name">${items[0].file_name}</span>
      </div>
    `;
  } else {
    const totalSize = items.reduce((sum, item) => sum + item.file_size, 0);
    ghost.innerHTML = `
      <div class="drag-ghost-content">
        <span class="file-icon">${getFileIcon(items[0])}</span>
        <span class="file-name">${items[0].file_name}</span>
        <div class="additional-count">+ ${items.length - 1}件のファイル</div>
        <div class="total-size">合計: ${formatFileSize(totalSize)}</div>
      </div>
    `;
  }

  ghost.style.position = 'absolute';
  ghost.style.top = '-9999px';
  ghost.style.left = '-9999px';
  ghost.style.opacity = '0.8';

  return ghost;
};
```

#### 2.4.2 ドロップターゲット

```typescript
const TagDropTarget: React.FC<{
  tag: Tag;
  onDrop: (tagId: number, fileIds: number[]) => void;
}> = ({ tag, onDrop }) => {
  const [isOver, setIsOver] = useState(false);
  const [canDrop, setCanDrop] = useState(true);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = canDrop ? 'copy' : 'none';
  };

  const handleDragEnter = (e: React.DragEvent) => {
    e.preventDefault();
    
    // ドロップ可否判定
    const data = e.dataTransfer.getData('application/json');
    if (data) {
      const { type } = JSON.parse(data);
      setCanDrop(type === 'files');
    }

    setIsOver(true);
  };

  const handleDragLeave = () => {
    setIsOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsOver(false);

    if (!canDrop) return;

    try {
      const data = JSON.parse(e.dataTransfer.getData('application/json'));
      if (data.type === 'files') {
        onDrop(tag.id, data.items);
        
        // ドロップ成功アニメーション
        playDropSuccessAnimation(e.currentTarget as HTMLElement);
      }
    } catch (error) {
      console.error('Drop failed:', error);
    }
  };

  return (
    <div
      className={`tag-item drop-target ${isOver ? 'drag-over' : ''} ${!canDrop ? 'invalid' : ''}`}
      onDragOver={handleDragOver}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <div className="tag-color" style={{ backgroundColor: tag.color }} />
      <span className="tag-name">{tag.tag_name}</span>
      <span className="tag-count">({tag.usage_count})</span>

      {isOver && (
        <div className="drop-hint">
          {canDrop ? (
            <>
              <PlusIcon size={16} />
              ドロップしてタグを追加
            </>
          ) : (
            <>
              <XIcon size={16} />
              このタグには追加できません
            </>
          )}
        </div>
      )}
    </div>
  );
};
```

#### 2.4.3 ドロップ成功アニメーション

```typescript
const playDropSuccessAnimation = (element: HTMLElement) => {
  // パルスアニメーション
  element.classList.add('drop-success');
  
  // パーティクル効果
  createParticles(element);

  setTimeout(() => {
    element.classList.remove('drop-success');
  }, 600);
};

const createParticles = (element: HTMLElement) => {
  const rect = element.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  for (let i = 0; i < 8; i++) {
    const particle = document.createElement('div');
    particle.className = 'drop-particle';
    
    const angle = (Math.PI * 2 * i) / 8;
    const distance = 40;
    const x = centerX + Math.cos(angle) * distance;
    const y = centerY + Math.sin(angle) * distance;

    particle.style.left = `${centerX}px`;
    particle.style.top = `${centerY}px`;
    particle.style.setProperty('--end-x', `${x}px`);
    particle.style.setProperty('--end-y', `${y}px`);

    document.body.appendChild(particle);

    setTimeout(() => {
      document.body.removeChild(particle);
    }, 500);
  }
};
```

#### 2.4.4 外部ファイルのドロップ

```typescript
const FileDropZone: React.FC<{
  onFileDrop: (files: string[]) => void;
}> = ({ onFileDrop }) => {
  const [isDragOver, setIsDragOver] = useState(false);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  };

  const handleDragEnter = (e: React.DragEvent) => {
    e.preventDefault();
    
    // 外部ファイルかどうか判定
    if (e.dataTransfer.types.includes('Files')) {
      setIsDragOver(true);
    }
  };

  const handleDragLeave = (e: React.DragEvent) => {
    // 子要素への移動は無視
    if (e.currentTarget.contains(e.relatedTarget as Node)) {
      return;
    }
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);

    const files = Array.from(e.dataTransfer.files);
    const paths = files.map(f => f.path);

    if (paths.length > 0) {
      onFileDrop(paths);
    }
  };

  return (
    <div
      className={`file-drop-zone ${isDragOver ? 'active' : ''}`}
      onDragOver={handleDragOver}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {isDragOver ? (
        <div className="drop-overlay">
          <UploadIcon size={64} />
          <h3>ファイルをドロップ</h3>
          <p>ドロップしてファイルを追加</p>
        </div>
      ) : (
        <div className="drop-hint-text">
          ファイルをドラッグ&ドロップ
        </div>
      )}
    </div>
  );
};
```

### 2.5 スタイル定義

```css
/* ドラッグゴースト */
.drag-ghost {
  background: var(--bg-paper);
  border: 2px solid var(--primary-main);
  border-radius: var(--radius-md);
  padding: 12px 16px;
  box-shadow: var(--shadow-xl);
  pointer-events: none;
  min-width: 200px;
}

.drag-ghost-content {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.additional-count {
  font-size: 13px;
  color: var(--text-secondary);
  font-weight: 600;
}

/* ドラッグ中の元要素 */
.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

/* ドロップターゲット */
.drop-target.drag-over {
  background: rgba(25, 118, 210, 0.1);
  border: 2px dashed var(--primary-main);
  animation: dragOverPulse 1s ease-in-out infinite;
}

.drop-target.drag-over.invalid {
  background: rgba(244, 67, 54, 0.1);
  border-color: var(--error);
}

@keyframes dragOverPulse {
  0%, 100% {
    background-color: rgba(25, 118, 210, 0.05);
  }
  50% {
    background-color: rgba(25, 118, 210, 0.15);
  }
}

.drop-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: var(--primary-main);
  color: white;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 600;
  white-space: nowrap;
  pointer-events: none;
  z-index: 10;
}

.drop-target.invalid .drop-hint {
  background: var(--error);
}

/* ドロップ成功アニメーション */
.drop-success {
  animation: dropSuccess 0.6s ease-out;
}

@keyframes dropSuccess {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
    box-shadow: 0 0 0 8px rgba(76, 175, 80, 0.3);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
  }
}

/* パーティクル */
.drop-particle {
  position: fixed;
  width: 8px;
  height: 8px;
  background: var(--primary-main);
  border-radius: 50%;
  pointer-events: none;
  animation: particleFly 0.5s ease-out forwards;
  z-index: 9999;
}

@keyframes particleFly {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(
      calc(var(--end-x) - 50%),
      calc(var(--end-y) - 50%)
    ) scale(0);
    opacity: 0;
  }
}

/* 外部ファイルドロップゾーン */
.file-drop-zone {
  position: relative;
  min-height: 200px;
  border: 2px dashed var(--divider);
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s;
}

.file-drop-zone.active {
  border-color: var(--primary-main);
  background: rgba(25, 118, 210, 0.05);
}

.drop-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  color: var(--primary-main);
  animation: fadeIn 0.2s;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.drop-hint-text {
  color: var(--text-tertiary);
  font-size: 14px;
}
```

### 2.6 アクセシビリティ対応

```typescript
// キーボードでのドラッグ&ドロップ代替
const KeyboardDragDrop: React.FC<{
  items: FileInfo[];
  onTagAssign: (tagId: number) => void;
}> = ({ items, onTagAssign }) => {
  const [isSelecting, setIsSelecting] = useState(false);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 't' && e.ctrlKey) {
      e.preventDefault();
      setIsSelecting(true);
    }
  };

  return (
    <>
      {isSelecting && (
        <TagSelectionDialog
          items={items}
          onSelect={onTagAssign}
          onClose={() => setIsSelecting(false)}
        />
      )}
    </>
  );
};
```

---

## 3. 統合使用例

```typescript
const MainScreen: React.FC = () => {
  const [searchTerms, setSearchTerms] = useState<string[]>([]);
  const { isDragging, draggedItems, handleDragStart, handleDragEnd } = useDragAndDrop();

  return (
    <div className={`main-screen ${isDragging ? 'dragging-active' : ''}`}>
      <Sidebar>
        <TagList
          onDrop={(tagId, fileIds) => {
            addTagsToFiles(fileIds, [tagId]);
            showNotification({
              type: 'success',
              message: `${fileIds.length}件のファイルにタグを追加しました`,
            });
          }}
        />
      </Sidebar>

      <FileListArea>
        <FileGrid
          files={files}
          searchTerms={searchTerms}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
        />
      </FileListArea>

      <FileDropZone
        onFileDrop={(paths) => {
          openFileAddDialog(paths);
        }}
      />
    </div>
  );
};
```
