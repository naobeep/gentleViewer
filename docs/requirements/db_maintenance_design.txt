# データベースメンテナンス画面 設計書

## 目次

1. [概要](#1-概要)
2. [画面構成](#2-画面構成)
3. [メンテナンス機能](#3-メンテナンス機能)
4. [バックアップ・復元](#4-バックアップ復元)
5. [データ整合性チェック](#5-データ整合性チェック)
6. [統計情報](#6-統計情報)

---

## 1. 概要

### 1.1 目的

データベースの健全性を保ち、パフォーマンスを最適化するためのメンテナンス機能を提供する。

### 1.2 主要機能

- **バックアップ・復元**: データの安全な保存と復旧
- **整合性チェック**: データの不整合検出と修復
- **最適化**: VACUUMによるデータベース最適化
- **統計情報**: ストレージ使用状況の可視化
- **クリーンアップ**: 不要データの削除

---

## 2. 画面構成

### 2.1 全体レイアウト

```txt
┌─────────────────────────────────────────────────────────┐
│ データベースメンテナンス                                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ [概要] [バックアップ] [整合性] [最適化] [統計] [詳細]   │
│                                                         │
│ ┌─────────────────────────────────────────────────────┐ │
│ │                                                     │ │
│ │                                                     │ │
│ │              各タブのコンテンツ                      │ │
│ │                                                     │ │
│ │                                                     │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ [閉じる]                                                │
└─────────────────────────────────────────────────────────┘
```

### 2.2 概要タブ

```txt
┌─────────────────────────────────────────────────────────┐
│ データベース概要                                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 📊 基本情報                                              │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ データベースファイル: main.db                        │ │
│ │ ファイルサイズ: 245.8 MB                             │ │
│ │ 最終更新: 2025-10-05 14:32:15                       │ │
│ │ バージョン: 3.0                                      │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 📈 データ統計                                            │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 総ファイル数: 1,234 件                               │ │
│ │ 総タグ数: 87 件                                      │ │
│ │ タグ付与数: 3,456 件                                 │ │
│ │ サムネイルキャッシュ: 892.3 MB                       │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ ⚠️ 推奨メンテナンス                                      │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ✓ 前回バックアップ: 3日前                            │ │
│ │ ⚠ 整合性チェック: 実行推奨 (30日経過)               │ │
│ │ ⚠ データベース最適化: 実行推奨 (15日経過)           │ │
│ │ ✓ キャッシュクリーンアップ: 昨日実行済み             │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ [クイックメンテナンス実行]                               │
└─────────────────────────────────────────────────────────┘
```

### 2.3 バックアップタブ

```txt
┌─────────────────────────────────────────────────────────┐
│ バックアップ・復元                                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 💾 バックアップ作成                                      │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 保存先: C:\Users\...\GentleViewer\backups           │ │
│ │                                        [参照...]     │ │
│ │                                                     │ │
│ │ ☑ データベースファイル                               │ │
│ │ ☑ 設定ファイル                                       │ │
│ │ ☐ サムネイルキャッシュ (892 MB)                      │ │
│ │ ☐ ログファイル                                       │ │
│ │                                                     │ │
│ │ 推定バックアップサイズ: 245.8 MB                     │ │
│ │                                                     │ │
│ │                      [今すぐバックアップ]            │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 📦 バックアップ履歴                                      │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 2025-10-05 14:30  manual     245.8 MB  [復元][削除] │ │
│ │ 2025-10-02 03:00  auto       243.1 MB  [復元][削除] │ │
│ │ 2025-09-29 03:00  auto       241.5 MB  [復元][削除] │ │
│ │ 2025-09-26 03:00  auto       238.9 MB  [復元][削除] │ │
│ │ 2025-09-23 03:00  auto       236.2 MB  [復元][削除] │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ ⚙️ 自動バックアップ設定                                  │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ☑ 自動バックアップを有効化                           │ │
│ │ 頻度: [毎日 3:00 AM ▾]                               │ │
│ │ 保持期間: [30日間 ▾]                                 │ │
│ │ 最大保存数: [10個 ▾]                                 │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.4 整合性チェックタブ

```txt
┌─────────────────────────────────────────────────────────┐
│ データ整合性チェック                                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 🔍 チェック項目                                          │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ ☑ ファイルの存在確認                                 │ │
│ │ ☑ 孤立タグの検出                                     │ │
│ │ ☑ 重複エントリの検出                                 │ │
│ │ ☑ 外部キー制約の検証                                 │ │
│ │ ☑ サムネイルキャッシュの整合性                       │ │
│ │ ☑ データベーススキーマの検証                         │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ [チェック開始]                                           │
│                                                         │
│ 📋 チェック結果                                          │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 最終チェック: 2025-09-05 10:23:45                   │ │
│ │                                                     │ │
│ │ ✓ ファイル存在確認: 1,234件中1,234件OK              │ │
│ │ ⚠ 孤立タグ: 3件検出                                  │ │
│ │   - 「未分類」 (使用ファイル: 0)                     │ │
│ │   - 「テスト」 (使用ファイル: 0)                     │ │
│ │   - 「古いタグ」 (使用ファイル: 0)                   │ │
│ │   [削除] [保持]                                      │ │
│ │                                                     │ │
│ │ ✗ 利用不可ファイル: 5件検出                          │ │
│ │   - old_archive.zip (パスが無効)                    │ │
│ │   - deleted_video.mp4 (ファイルが存在しない)        │ │
│ │   - moved_file.pdf (パスが変更された)               │ │
│ │   [詳細を表示...] [DBから削除]                       │ │
│ │                                                     │ │
│ │ ✓ 外部キー制約: 問題なし                             │ │
│ │ ✓ データベーススキーマ: 正常                         │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ [問題を自動修復]                                         │
└─────────────────────────────────────────────────────────┘
```

### 2.5 最適化タブ

```txt
┌─────────────────────────────────────────────────────────┐
│ データベース最適化                                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 🚀 最適化オプション                                      │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ VACUUM (データベース再構築)                          │ │
│ │ ┌───────────────────────────────────────────────────┐ │
│ │ │ 断片化されたデータを整理し、ファイルサイズを削減   │ │
│ │ │ 推定効果: 24.5 MB削減 (10%削減)                   │ │
│ │ │ 推定時間: 約2分                                   │ │
│ │ │                                                   │ │
│ │ │ [VACUUM実行]                                      │ │
│ │ └───────────────────────────────────────────────────┘ │
│ │                                                     │ │
│ │ ANALYZE (統計情報更新)                               │ │
│ │ ┌───────────────────────────────────────────────────┐ │
│ │ │ クエリプランナーの統計を更新し、検索速度を改善     │ │
│ │ │ 推定時間: 約30秒                                  │ │
│ │ │                                                   │ │
│ │ │ [ANALYZE実行]                                     │ │
│ │ └───────────────────────────────────────────────────┘ │
│ │                                                     │ │
│ │ REINDEX (インデックス再構築)                         │ │
│ │ ┌───────────────────────────────────────────────────┐ │
│ │ │ すべてのインデックスを再構築し、パフォーマンス向上 │ │
│ │ │ 推定時間: 約1分                                   │ │
│ │ │                                                   │ │
│ │ │ [REINDEX実行]                                     │ │
│ │ └───────────────────────────────────────────────────┘ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 🗑️ キャッシュクリーンアップ                              │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ サムネイルキャッシュ: 892.3 MB                       │ │
│ │ ☑ 30日以上未使用のキャッシュを削除                   │ │
│ │ ☑ 削除されたファイルのキャッシュを削除               │ │
│ │ 推定削減: 145.6 MB                                   │ │
│ │                                                     │ │
│ │ [キャッシュクリーンアップ実行]                       │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 📊 最適化履歴                                            │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 2025-09-20 15:30  VACUUM    削減: 28.3 MB          │ │
│ │ 2025-09-20 15:32  ANALYZE   完了                    │ │
│ │ 2025-09-05 10:15  VACUUM    削減: 31.7 MB          │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.6 統計タブ

```txt
┌─────────────────────────────────────────────────────────┐
│ ストレージ統計                                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 💾 ストレージ使用状況                                    │
│ ┌─────────────────────────────────────────────────────┐ │
│ │                                                     │ │
│ │  データベース   [████████░░] 245.8 MB (21%)         │ │
│ │  サムネイル     [████████████████░░] 892.3 MB (76%) │ │
│ │  ログ          [█░] 12.4 MB (1%)                    │ │
│ │  設定          [░] 2.1 MB (0%)                      │ │
│ │  バックアップ   [██░] 98.7 MB (8%)                  │ │
│ │                                                     │ │
│ │  合計: 1.22 GB                                      │ │
│ │                                                     │ │
│ │            [円グラフ表示]                            │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 📊 テーブル統計                                          │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ テーブル名        レコード数    サイズ    インデックス│ │
│ │ ──────────────────────────────────────────────────│ │
│ │ files            1,234件      180.5 MB   45.2 MB   │ │
│ │ tags                87件        1.2 MB    0.3 MB   │ │
│ │ file_tags        3,456件       12.8 MB    8.1 MB   │ │
│ │ bookmarks          234件        2.3 MB    0.8 MB   │ │
│ │ viewer_settings    156件        1.5 MB    0.4 MB   │ │
│ │ saved_searches      12件        0.1 MB    0.0 MB   │ │
│ │ settings            23件        0.0 MB    0.0 MB   │ │
│ └─────────────────────────────────────────────────────┘ │
│                                                         │
│ 📈 成長トレンド (過去30日)                               │
│ ┌─────────────────────────────────────────────────────┐ │
│ │                     ╱                               │ │
│ │                   ╱                                 │ │
│ │                 ╱                                   │ │
│ │               ╱                                     │ │
│ │             ╱                                       │ │
│ │   ────────────────────────────────                 │ │
│ │   9/5    9/12   9/19   9/26   10/3                 │ │
│ │                                                     │ │
│ │ ファイル数: +234件 (+23%)                            │ │
│ │ DB サイズ: +45.6MB (+22%)                           │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

---

## 3. メンテナンス機能

### 3.1 実装

#### 3.1.1 型定義

```typescript
interface DatabaseInfo {
  path: string;
  size: number;
  lastModified: Date;
  version: string;
}

interface DatabaseStats {
  totalFiles: number;
  totalTags: number;
  totalTagAssignments: number;
  thumbnailCacheSize: number;
  logSize: number;
  backupSize: number;
}

interface MaintenanceStatus {
  lastBackup: Date | null;
  lastIntegrityCheck: Date | null;
  lastOptimization: Date | null;
  lastCacheCleanup: Date | null;
}

interface IntegrityIssue {
  type: 'orphan_tag' | 'missing_file' | 'duplicate' | 'constraint_violation';
  severity: 'error' | 'warning' | 'info';
  description: string;
  affectedItems: any[];
  canAutoFix: boolean;
}
```

#### 3.1.2 メインコンポーネント

```typescript
const DatabaseMaintenanceDialog: React.FC<{
  isOpen: boolean;
  onClose: () => void;
}> = ({ isOpen, onClose }) => {
  const [activeTab, setActiveTab] = useState<'overview' | 'backup' | 'integrity' | 'optimize' | 'stats'>('overview');
  const [dbInfo, setDbInfo] = useState<DatabaseInfo | null>(null);
  const [stats, setStats] = useState<DatabaseStats | null>(null);
  const [maintenanceStatus, setMaintenanceStatus] = useState<MaintenanceStatus | null>(null);

  useEffect(() => {
    if (isOpen) {
      loadDatabaseInfo();
    }
  }, [isOpen]);

  const loadDatabaseInfo = async () => {
    const info = await window.electronAPI.getDatabaseInfo();
    const dbStats = await window.electronAPI.getDatabaseStats();
    const status = await window.electronAPI.getMaintenanceStatus();

    setDbInfo(info);
    setStats(dbStats);
    setMaintenanceStatus(status);
  };

  if (!isOpen) return null;

  return (
    <div className="dialog-overlay" onClick={onClose}>
      <div className="dialog database-maintenance-dialog large" onClick={(e) => e.stopPropagation()}>
        <div className="dialog-header">
          <h2>データベースメンテナンス</h2>
          <button className="close-button" onClick={onClose}>×</button>
        </div>

        <div className="dialog-tabs">
          <button
            className={activeTab === 'overview' ? 'active' : ''}
            onClick={() => setActiveTab('overview')}
          >
            概要
          </button>
          <button
            className={activeTab === 'backup' ? 'active' : ''}
            onClick={() => setActiveTab('backup')}
          >
            バックアップ
          </button>
          <button
            className={activeTab === 'integrity' ? 'active' : ''}
            onClick={() => setActiveTab('integrity')}
          >
            整合性
          </button>
          <button
            className={activeTab === 'optimize' ? 'active' : ''}
            onClick={() => setActiveTab('optimize')}
          >
            最適化
          </button>
          <button
            className={activeTab === 'stats' ? 'active' : ''}
            onClick={() => setActiveTab('stats')}
          >
            統計
          </button>
        </div>

        <div className="dialog-content">
          {activeTab === 'overview' && (
            <OverviewTab
              dbInfo={dbInfo}
              stats={stats}
              maintenanceStatus={maintenanceStatus}
            />
          )}
          {activeTab === 'backup' && (
            <BackupTab onBackupComplete={loadDatabaseInfo} />
          )}
          {activeTab === 'integrity' && (
            <IntegrityTab />
          )}
          {activeTab === 'optimize' && (
            <OptimizeTab onOptimizeComplete={loadDatabaseInfo} />
          )}
          {activeTab === 'stats' && (
            <StatsTab stats={stats} />
          )}
        </div>

        <div className="dialog-footer">
          <button onClick={onClose}>閉じる</button>
        </div>
      </div>
    </div>
  );
};
```

---

## 4. バックアップ・復元

### 4.1 バックアップタブ実装

```typescript
const BackupTab: React.FC<{
  onBackupComplete: () => void;
}> = ({ onBackupComplete }) => {
  const [backupPath, setBackupPath] = useState('');
  const [backupItems, setBackupItems] = useState({
    database: true,
    settings: true,
    thumbnails: false,
    logs: false,
  });
  const [backupHistory, setBackupHistory] = useState<BackupRecord[]>([]);
  const [isBackingUp, setIsBackingUp] = useState(false);
  const [autoBackupEnabled, setAutoBackupEnabled] = useState(true);

  useEffect(() => {
    loadBackupHistory();
    loadBackupSettings();
  }, []);

  const loadBackupHistory = async () => {
    const history = await window.electronAPI.getBackupHistory();
    setBackupHistory(history);
  };

  const loadBackupSettings = async () => {
    const settings = await window.electronAPI.getBackupSettings();
    setBackupPath(settings.path);
    setAutoBackupEnabled(settings.autoBackupEnabled);
  };

  const handleCreateBackup = async () => {
    setIsBackingUp(true);
    try {
      await window.electronAPI.createBackup({
        path: backupPath,
        items: backupItems,
      });

      await loadBackupHistory();
      onBackupComplete();

      showNotification({
        type: 'success',
        message: 'バックアップが完了しました',
      });
    } catch (error) {
      showNotification({
        type: 'error',
        message: 'バックアップに失敗しました',
      });
    } finally {
      setIsBackingUp(false);
    }
  };

  const handleRestore = async (backupId: string) => {
    const confirmed = await showConfirmDialog({
      title: 'バックアップを復元',
      message: '現在のデータは上書きされます。続行しますか？',
      confirmText: '復元',
      cancelText: 'キャンセル',
      type: 'warning',
    });

    if (confirmed) {
      try {
        await window.electronAPI.restoreBackup(backupId);
        
        showNotification({
          type: 'success',
          message: 'バックアップを復元しました。アプリを再起動してください。',
        });

        // アプリ再起動
        window.electronAPI.relaunchApp();
      } catch (error) {
        showNotification({
          type: 'error',
          message: '復元に失敗しました',
        });
      }
    }
  };

  const estimatedSize = calculateBackupSize(backupItems);

  return (
    <div className="backup-tab">
      <section className="backup-create">
        <h3>💾 バックアップ作成</h3>
        
        <div className="form-group">
          <label>保存先</label>
          <div className="path-input">
            <input
              type="text"
              value={backupPath}
              onChange={(e) => setBackupPath(e.target.value)}
              readOnly
            />
            <button onClick={async () => {
              const result = await window.electronAPI.selectFolder();
              if (result) setBackupPath(result);
            }}>
              参照...
            </button>
          </div>
        </div>

        <div className="backup-items">
          <label>
            <input
              type="checkbox"
              checked={backupItems.database}
              onChange={(e) => setBackupItems(prev => ({
                ...prev,
                database: e.target.checked
              }))}
            />
            データベースファイル
          </label>
          <label>
            <input
              type="checkbox"
              checked={backupItems.settings}
              onChange={(e) => setBackupItems(prev => ({
                ...prev,
                settings: e.target.checked
              }))}
            />
            設定ファイル
          </label>
          <label>
            <input
              type="checkbox"
              checked={backupItems.thumbnails}
              onChange={(e) => setBackupItems(prev => ({
                ...prev,
                thumbnails: e.target.checked
              }))}
            />
            サムネイルキャッシュ (892 MB)
          </label>
          <label>
            <input
              type="checkbox"
              checked={backupItems.logs}
              onChange={(e) => setBackupItems(prev => ({
                ...prev,
                logs: e.target.checked
              }))}
            />
            ログファイル
          </label>
        </div>

        <div className="estimated-size">
          推定バックアップサイズ: {formatFileSize(estimatedSize)}
        </div>

        <button
          className="primary"
          onClick={handleCreateBackup}
          disabled={isBackingUp}
        >
          {isBackingUp ? 'バックアップ中...' : '今すぐバックアップ'}
        </button>
      </section>

      <section className="backup-history">
        <h3>📦 バックアップ履歴</h3>
        <div className="backup-list">
          {backupHistory.map(backup => (
            <div key={backup.id} className="backup-item">
              <div className="backup-info">
                <span className="backup-date">
                  {formatDate(backup.createdAt)}
                </span>
                <span className="backup-type">
                  {backup.type === 'manual' ? '手動' : '自動'}
                </span>
                <span className="backup-size">
                  {formatFileSize(backup.size)}
                </span>
              </div>
              <div className="backup-actions">
                <button onClick={() => handleRestore(backup.id)}>
                  復元
                </button>
                <button onClick={() => deleteBackup(backup.id)}>
                  削除
                </button>
              </div>
            </div>
          ))}
        </div>
      </section>

      <section className="auto-backup-settings">
        <h3>⚙️ 自動バックアップ設定</h3>
        <label>
          <input
            type="checkbox"
            checked={autoBackupEnabled}
            onChange={(e) => {
              setAutoBackupEnabled(e.target.checked);
              window.electronAPI.setAutoBackup(e.target.checked);
            }}
          />
          自動バックアップを有効化
        </label>
        {/* 追加の設定項目 */}
      </section>
    </div>
  );
};
```

---

## 5. データ整合性チェック

### 5.1 整合性チェック実装

```typescript
const IntegrityTab: React.FC = () => {
  const [checkItems, setCheckItems] = useState({
    fileExistence: true,
    orphanTags: true,
    duplicates: true,
    constraints: true,
    thumbnails: true,
    schema: true,
  });
  const [issues, setIssues] = useState<IntegrityIssue[]>([]);
  const [isChecking, setIsChecking] = useState(false);
  const [lastCheckDate, setLastCheckDate] = useState<Date | null>(null);

  const handleCheck = async () => {
    setIsChecking(true);
    try {
      const result = await window.electronAPI.checkIntegrity(checkItems);
      setIssues(result.issues);
      setLastCheckDate(new Date());
    } catch (error) {
      showNotification({
        type: 'error',
        message: 'チェックに失敗しました',
      });
    } finally {
      setIsChecking(false);
    }
  };

  const handleAutoFix = async () => {
    const fixableIssues = issues.filter(issue => issue.canAutoFix);
    
    if (fixableIssues.length === 0) {
      showNotification({
        type: 'info',
        message: '自動修復可能な問題はありません',
      });
      return;
    }

    try {
      await window.electronAPI.autoFixIssues(fixableIssues);
      await handleCheck(); // 再チェック
      
      showNotification({
        type: 'success',
        message: `${fixableIssues.length}件の問題を修復しました`,
      });
    } catch (error) {
      showNotification({
        type: 'error',
        message: '修復に失敗しました',
      });
    }
  };

  return (
    <div className="integrity-tab">
      <section className="check-items">
        <h3>🔍 チェック項目</h3>
        {Object.entries(checkItems).map(([key, value]) => (
          <label key={key}>
            <input
              type="checkbox"
              checked={value}
              onChange={(e) => setCheckItems(prev => ({
                ...prev,
                [key]: e.target.checked
              }))}
            />
            {getCheckItemLabel(key)}
          </label>
        ))}
      </section>

      <button
        className="primary"
        onClick={handleCheck}
        disabled={isChecking}
      >
        {isChecking ? 'チェック中...' : 'チェック開始'}
      </button>

      {lastCheckDate && (
        <section className="check-results">
          <h3>📋 チェック結果</h3>
          <p className="check-date">
            最終チェック: {formatDateTime(lastCheckDate)}
          </p>

          {issues.length === 0 ? (
            <div className="no-issues">
              ✓ 問題は検出されませんでした
            </div>
          ) : (
            <div className="issues-list">
              {issues.map((issue, index) => (
                <IssueItem
                  key={index}
                  issue={issue}
                  onFix={() => handleAutoFix()}
                />
              ))}
            </div>
          )}

          {issues.some(i => i.canAutoFix) && (
            <button className="primary" onClick={handleAutoFix}>
              問題を自動修復
            </button>
          )}
        </section>
      )}
    </div>
  );
};

const IssueItem: React.FC<{
  issue: IntegrityIssue;
  onFix: () => void;
}> = ({ issue, onFix }) => {
  const [expanded, setExpanded] = useState(false);

  const getSeverityIcon = () => {
    switch (issue.severity) {
      case 'error': return '✗';
      case 'warning': return '⚠';
      case 'info': return 'ℹ';
    }
  };

  const getSeverityClass = () => {
    return `issue-${issue.severity}`;
  };

  return (
    <div className={`issue-item ${getSeverityClass()}`}>
      <div className="issue-header" onClick={() => setExpanded(!expanded)}>
        <span className="issue-icon">{getSeverityIcon()}</span>
        <span className="issue-description">{issue.description}</span>
        <span className="issue-count">
          {issue.affectedItems.length}件
        </span>
        {issue.canAutoFix && (
          <span className="can-fix">修復可能</span>
        )}
        <button className="expand-button">
          {expanded ? '▼' : '▶'}
        </button>
      </div>

      {expanded && (
        <div className="issue-details">
          <div className="affected-items">
            {issue.affectedItems.slice(0, 10).map((item, index) => (
              <div key={index} className="affected-item">
                {typeof item === 'string' ? item : JSON.stringify(item)}
              </div>
            ))}
            {issue.affectedItems.length > 10 && (
              <p className="more-items">
                他 {issue.affectedItems.length - 10} 件
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

const getCheckItemLabel = (key: string): string => {
  const labels: Record<string, string> = {
    fileExistence: 'ファイルの存在確認',
    orphanTags: '孤立タグの検出',
    duplicates: '重複エントリの検出',
    constraints: '外部キー制約の検証',
    thumbnails: 'サムネイルキャッシュの整合性',
    schema: 'データベーススキーマの検証',
  };
  return labels[key] || key;
};
```

---

## 6. 統計情報

### 6.1 統計タブ実装

```typescript
const StatsTab: React.FC<{
  stats: DatabaseStats | null;
}> = ({ stats }) => {
  const [storageBreakdown, setStorageBreakdown] = useState<StorageBreakdown | null>(null);
  const [tableStats, setTableStats] = useState<TableStats[]>([]);
  const [growthTrend, setGrowthTrend] = useState<GrowthData[]>([]);

  useEffect(() => {
    loadStorageBreakdown();
    loadTableStats();
    loadGrowthTrend();
  }, []);

  const loadStorageBreakdown = async () => {
    const data = await window.electronAPI.getStorageBreakdown();
    setStorageBreakdown(data);
  };

  const loadTableStats = async () => {
    const data = await window.electronAPI.getTableStats();
    setTableStats(data);
  };

  const loadGrowthTrend = async () => {
    const data = await window.electronAPI.getGrowthTrend(30); // 過去30日
    setGrowthTrend(data);
  };

  if (!stats || !storageBreakdown) {
    return <div>読み込み中...</div>;
  }

  return (
    <div className="stats-tab">
      <section className="storage-usage">
        <h3>💾 ストレージ使用状況</h3>
        
        <div className="storage-bars">
          <StorageBar
            label="データベース"
            size={storageBreakdown.database}
            total={storageBreakdown.total}
            color="#1976d2"
          />
          <StorageBar
            label="サムネイル"
            size={storageBreakdown.thumbnails}
            total={storageBreakdown.total}
            color="#4caf50"
          />
          <StorageBar
            label="ログ"
            size={storageBreakdown.logs}
            total={storageBreakdown.total}
            color="#ff9800"
          />
          <StorageBar
            label="設定"
            size={storageBreakdown.settings}
            total={storageBreakdown.total}
            color="#9c27b0"
          />
          <StorageBar
            label="バックアップ"
            size={storageBreakdown.backups}
            total={storageBreakdown.total}
            color="#f44336"
          />
        </div>

        <div className="total-size">
          合計: {formatFileSize(storageBreakdown.total)}
        </div>

        <div className="storage-chart">
          <PieChart data={storageBreakdown} />
        </div>
      </section>

      <section className="table-stats">
        <h3>📊 テーブル統計</h3>
        <table className="stats-table">
          <thead>
            <tr>
              <th>テーブル名</th>
              <th>レコード数</th>
              <th>サイズ</th>
              <th>インデックス</th>
            </tr>
          </thead>
          <tbody>
            {tableStats.map(table => (
              <tr key={table.name}>
                <td>{table.name}</td>
                <td>{table.rowCount.toLocaleString()}件</td>
                <td>{formatFileSize(table.dataSize)}</td>
                <td>{formatFileSize(table.indexSize)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>

      <section className="growth-trend">
        <h3>📈 成長トレンド (過去30日)</h3>
        <div className="trend-chart">
          <LineChart data={growthTrend} />
        </div>
        <div className="trend-summary">
          <div className="trend-item">
            <span className="label">ファイル数:</span>
            <span className="value">
              +{growthTrend[growthTrend.length - 1]?.fileCountDelta || 0}件
              ({calculatePercentage(growthTrend, 'fileCount')}%)
            </span>
          </div>
          <div className="trend-item">
            <span className="label">DB サイズ:</span>
            <span className="value">
              +{formatFileSize(growthTrend[growthTrend.length - 1]?.dbSizeDelta || 0)}
              ({calculatePercentage(growthTrend, 'dbSize')}%)
            </span>
          </div>
        </div>
      </section>
    </div>
  );
};

const StorageBar: React.FC<{
  label: string;
  size: number;
  total: number;
  color: string;
}> = ({ label, size, total, color }) => {
  const percentage = (size / total) * 100;

  return (
    <div className="storage-bar">
      <div className="bar-label">
        <span>{label}</span>
        <span>{formatFileSize(size)} ({percentage.toFixed(0)}%)</span>
      </div>
      <div className="bar-track">
        <div
          className="bar-fill"
          style={{
            width: `${percentage}%`,
            backgroundColor: color,
          }}
        />
      </div>
    </div>
  );
};

const PieChart: React.FC<{
  data: StorageBreakdown;
}> = ({ data }) => {
  const chartData = [
    { name: 'データベース', value: data.database, color: '#1976d2' },
    { name: 'サムネイル', value: data.thumbnails, color: '#4caf50' },
    { name: 'ログ', value: data.logs, color: '#ff9800' },
    { name: '設定', value: data.settings, color: '#9c27b0' },
    { name: 'バックアップ', value: data.backups, color: '#f44336' },
  ];

  // 簡易的な円グラフ実装（実際はrecharts等を使用）
  return (
    <div className="pie-chart">
      <svg viewBox="0 0 200 200" width="200" height="200">
        {/* 円グラフの描画ロジック */}
      </svg>
      <div className="chart-legend">
        {chartData.map(item => (
          <div key={item.name} className="legend-item">
            <div
              className="legend-color"
              style={{ backgroundColor: item.color }}
            />
            <span>{item.name}</span>
          </div>
        ))}
      </div>
    </div>
  );
};

const LineChart: React.FC<{
  data: GrowthData[];
}> = ({ data }) => {
  // 簡易的な折れ線グラフ（実際はrecharts等を使用）
  return (
    <div className="line-chart">
      {/* グラフ描画 */}
    </div>
  );
};

interface StorageBreakdown {
  database: number;
  thumbnails: number;
  logs: number;
  settings: number;
  backups: number;
  total: number;
}

interface TableStats {
  name: string;
  rowCount: number;
  dataSize: number;
  indexSize: number;
}

interface GrowthData {
  date: string;
  fileCount: number;
  dbSize: number;
  fileCountDelta: number;
  dbSizeDelta: number;
}
```

---

## 7. メインプロセス実装

### 7.1 データベースメンテナンスサービス

```typescript
// main/services/database-maintenance.ts
import { Database } from 'better-sqlite3';
import * as fs from 'fs';
import * as path from 'path';

export class DatabaseMaintenanceService {
  constructor(private db: Database) {}

  // バックアップ作成
  async createBackup(options: BackupOptions): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = options.path || path.join(app.getPath('userData'), 'backups');
    const backupPath = path.join(backupDir, `backup_${timestamp}`);

    await fs.promises.mkdir(backupPath, { recursive: true });

    // データベースバックアップ
    if (options.items.database) {
      await this.backupDatabase(backupPath);
    }

    // 設定ファイルバックアップ
    if (options.items.settings) {
      await this.backupSettings(backupPath);
    }

    // サムネイルバックアップ
    if (options.items.thumbnails) {
      await this.backupThumbnails(backupPath);
    }

    // ログバックアップ
    if (options.items.logs) {
      await this.backupLogs(backupPath);
    }

    // バックアップ情報を保存
    const backupInfo = {
      id: timestamp,
      createdAt: new Date(),
      type: 'manual',
      size: await this.calculateDirectorySize(backupPath),
      items: options.items,
    };

    await fs.promises.writeFile(
      path.join(backupPath, 'backup-info.json'),
      JSON.stringify(backupInfo, null, 2)
    );

    return backupPath;
  }

  // データベースバックアップ
  private async backupDatabase(backupPath: string): Promise<void> {
    const dbPath = this.db.name;
    const backupDbPath = path.join(backupPath, 'main.db');

    // SQLiteのBACKUPコマンド使用
    await this.db.backup(backupDbPath);
  }

  // 整合性チェック
  async checkIntegrity(options: IntegrityCheckOptions): Promise<IntegrityCheckResult> {
    const issues: IntegrityIssue[] = [];

    // ファイル存在確認
    if (options.fileExistence) {
      const fileIssues = await this.checkFileExistence();
      issues.push(...fileIssues);
    }

    // 孤立タグ検出
    if (options.orphanTags) {
      const orphanIssues = await this.checkOrphanTags();
      issues.push(...orphanIssues);
    }

    // 重複検出
    if (options.duplicates) {
      const duplicateIssues = await this.checkDuplicates();
      issues.push(...duplicateIssues);
    }

    // 外部キー制約検証
    if (options.constraints) {
      const constraintIssues = await this.checkConstraints();
      issues.push(...constraintIssues);
    }

    return {
      issues,
      checkedAt: new Date(),
    };
  }

  private async checkFileExistence(): Promise<IntegrityIssue[]> {
    const files = this.db.prepare('SELECT id, file_path FROM files WHERE is_available = 1').all();
    const missingFiles: any[] = [];

    for (const file of files) {
      try {
        await fs.promises.access(file.file_path);
      } catch {
        missingFiles.push(file);
      }
    }

    if (missingFiles.length > 0) {
      return [{
        type: 'missing_file',
        severity: 'error',
        description: `${missingFiles.length}件のファイルが見つかりません`,
        affectedItems: missingFiles,
        canAutoFix: true, // is_available = 0 に更新可能
      }];
    }

    return [];
  }

  private async checkOrphanTags(): Promise<IntegrityIssue[]> {
    const orphanTags = this.db.prepare(`
      SELECT t.id, t.tag_name
      FROM tags t
      LEFT JOIN file_tags ft ON t.id = ft.tag_id
      WHERE ft.id IS NULL
    `).all();

    if (orphanTags.length > 0) {
      return [{
        type: 'orphan_tag',
        severity: 'warning',
        description: `${orphanTags.length}件の未使用タグがあります`,
        affectedItems: orphanTags,
        canAutoFix: true, // 削除可能
      }];
    }

    return [];
  }

  // VACUUM実行
  async vacuum(): Promise<VacuumResult> {
    const beforeSize = await this.getDatabaseSize();
    
    this.db.prepare('VACUUM').run();
    
    const afterSize = await this.getDatabaseSize();
    const savedSize = beforeSize - afterSize;

    return {
      beforeSize,
      afterSize,
      savedSize,
      percentage: (savedSize / beforeSize) * 100,
    };
  }

  // ANALYZE実行
  async analyze(): Promise<void> {
    this.db.prepare('ANALYZE').run();
  }

  // REINDEX実行
  async reindex(): Promise<void> {
    this.db.prepare('REINDEX').run();
  }

  // ストレージ統計取得
  async getStorageBreakdown(): Promise<StorageBreakdown> {
    const userDataPath = app.getPath('userData');

    const dbSize = await this.getDatabaseSize();
    const thumbnailSize = await this.getDirectorySize(path.join(userDataPath, 'cache', 'thumbnails'));
    const logSize = await this.getDirectorySize(path.join(userDataPath, 'logs'));
    const settingsSize = await this.getDirectorySize(path.join(userDataPath, 'config'));
    const backupSize = await this.getDirectorySize(path.join(userDataPath, 'backups'));

    return {
      database: dbSize,
      thumbnails: thumbnailSize,
      logs: logSize,
      settings: settingsSize,
      backups: backupSize,
      total: dbSize + thumbnailSize + logSize + settingsSize + backupSize,
    };
  }

  private async getDatabaseSize(): Promise<number> {
    const stats = await fs.promises.stat(this.db.name);
    return stats.size;
  }

  private async getDirectorySize(dirPath: string): Promise<number> {
    try {
      let totalSize = 0;
      const files = await fs.promises.readdir(dirPath, { withFileTypes: true });

      for (const file of files) {
        const filePath = path.join(dirPath, file.name);
        if (file.isDirectory()) {
          totalSize += await this.getDirectorySize(filePath);
        } else {
          const stats = await fs.promises.stat(filePath);
          totalSize += stats.size;
        }
      }

      return totalSize;
    } catch {
      return 0;
    }
  }
}
```

---

## 8. スタイル定義

```css
.database-maintenance-dialog {
  width: 800px;
  max-height: 80vh;
}

.dialog-tabs {
  display: flex;
  border-bottom: 1px solid var(--divider);
  padding: 0 24px;
  gap: 4px;
}

.dialog-tabs button {
  padding: 12px 20px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  transition: all 0.2s;
}

.dialog-tabs button:hover {
  color: var(--text-primary);
  background: var(--bg-hover);
}

.dialog-tabs button.active {
  color: var(--primary-main);
  border-bottom-color: var(--primary-main);
}

/* ストレージバー */
.storage-bar {
  margin-bottom: 16px;
}

.bar-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
  font-size: 13px;
}

.bar-track {
  height: 8px;
  background: var(--bg-secondary);
  border-radius: var(--radius-full);
  overflow: hidden;
}

.bar-fill {
  height: 100%;
  transition: width 0.3s ease;
}

/* 整合性問題 */
.issue-item {
  border: 1px solid var(--divider);
  border-radius: var(--radius-sm);
  margin-bottom: 8px;
  overflow: hidden;
}

.issue-item.issue-error {
  border-left: 4px solid var(--error);
}

.issue-item.issue-warning {
  border-left: 4px solid var(--warning);
}

.issue-item.issue-info {
  border-left: 4px solid var(--info);
}

.issue-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  cursor: pointer;
  transition: background 0.2s;
}

.issue-header:hover {
  background: var(--bg-hover);
}

.issue-icon {
  font-size: 18px;
}

.issue-description {
  flex: 1;
}

.can-fix {
  padding: 2px 8px;
  background: var(--success);
  color: white;
  border-radius: var(--radius-sm);
  font-size: 11px;
  font-weight: 600;
}

.issue-details {
  padding: 16px;
  background: var(--bg-secondary);
  border-top: 1px solid var(--divider);
}

.affected-items {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.affected-item {
  padding: 4px 8px;
  background: var(--bg-paper);
  border-radius: var(--radius-xs);
  font-family: monospace;
  font-size: 12px;
}
```
