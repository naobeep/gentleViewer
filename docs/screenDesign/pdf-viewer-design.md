# PDFãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ è©³ç´°è¨­è¨ˆæ›¸

## ç›®æ¬¡

1. [ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼æ¦‚è¦](#1-ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼æ¦‚è¦)
2. [ç”»é¢æ§‹æˆ](#2-ç”»é¢æ§‹æˆ)
3. [PDFå‡¦ç†](#3-pdfå‡¦ç†)
4. [ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³](#4-ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³)
5. [è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰](#5-è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰)
6. [ã‚ºãƒ¼ãƒ ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«](#6-ã‚ºãƒ¼ãƒ ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«)
7. [ãƒ†ã‚­ã‚¹ãƒˆæ©Ÿèƒ½](#7-ãƒ†ã‚­ã‚¹ãƒˆæ©Ÿèƒ½)
8. [ã—ãŠã‚Šæ©Ÿèƒ½](#8-ã—ãŠã‚Šæ©Ÿèƒ½)
9. [å°åˆ·æ©Ÿèƒ½](#9-å°åˆ·æ©Ÿèƒ½)
10. [ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ](#10-ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ)
11. [çµ±åˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ](#11-çµ±åˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ)

---

## 1. ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼æ¦‚è¦

### 1.1 ç›®çš„

PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¿«é©ã«é–²è¦§ãƒ»ç®¡ç†ã§ãã‚‹çµ±åˆPDFãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã€‚

### 1.2 ä¸»è¦æ©Ÿèƒ½

- **PDF.jsçµ±åˆ**: Mozillaã®ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä½¿ç”¨
- **ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³**: é«˜é€Ÿãƒšãƒ¼ã‚¸ã‚ãã‚Š
- **è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰**: å˜ãƒšãƒ¼ã‚¸ãƒ»è¦‹é–‹ããƒ»é€£ç¶šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
- **ã‚ºãƒ¼ãƒ æ©Ÿèƒ½**: ãƒ•ã‚£ãƒƒãƒˆãƒ»ã‚«ã‚¹ã‚¿ãƒ ã‚ºãƒ¼ãƒ 
- **ãƒ†ã‚­ã‚¹ãƒˆé¸æŠ**: ã‚³ãƒ”ãƒ¼ãƒ»æ¤œç´¢
- **ã—ãŠã‚Šæ©Ÿèƒ½**: èª­æ›¸ä½ç½®è¨˜æ†¶
- **å°åˆ·æ©Ÿèƒ½**: ãƒšãƒ¼ã‚¸ç¯„å›²æŒ‡å®šå°åˆ·
- **ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³è¡¨ç¤º**: ç›®æ¬¡ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³

### 1.3 æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **PDF.js**: v3.xä»¥é™
- **React**: 18.x
- **TypeScript**: 5.x
- **Canvas API**: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°

---

## 2. ç”»é¢æ§‹æˆ

### 2.1 å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ãƒ˜ãƒƒãƒ€ãƒ¼ (é«˜ã•: 56px, è‡ªå‹•éè¡¨ç¤º)                             â”‚
â”‚ [â—€] document.pdf (15/120) [è¦‹é–‹ãâ–¾] [æ¤œç´¢] [âš™] [Ã—]          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           â”‚ ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ (é«˜ã•: 48px)                           â”‚
â”‚ ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³â”‚ [å˜ãƒšãƒ¼ã‚¸] [è¦‹é–‹ã] [é€£ç¶š] [100%â–¾] [å›è»¢] [å°åˆ·] â”‚
â”‚           â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ (240px)   â”‚ â”‚                                              â”‚â”‚
â”‚ æŠ˜ã‚ŠãŸãŸã¿ â”‚ â”‚ PDFãƒšãƒ¼ã‚¸è¡¨ç¤ºã‚¨ãƒªã‚¢                          â”‚â”‚
â”‚ å¯èƒ½      â”‚ â”‚ (Canvas)                                     â”‚â”‚
â”‚           â”‚ â”‚                                              â”‚â”‚
â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ (é«˜ã•: 32px)                                   â”‚
â”‚ ãƒšãƒ¼ã‚¸ 15/120 | 100% | "æ¤œç´¢ä¸­..." 3ä»¶è¦‹ã¤ã‹ã‚Šã¾ã—ãŸ          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ãƒ˜ãƒƒãƒ€ãƒ¼è©³ç´°

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â—€] document.pdf (15/120) [â‰¡] [è¦‹é–‹ãâ–¾] [ğŸ”] [âš™] [â”€][â–¡][Ã—] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è¦ç´ :**

| è¦ç´  | èª¬æ˜ | ã‚µã‚¤ã‚º |
|-----|------|-------|
| `[â—€]` | å‰ã®ãƒ•ã‚¡ã‚¤ãƒ« | 40x40px |
| ãƒ•ã‚¡ã‚¤ãƒ«å | ç¾åœ¨ã®PDFãƒ•ã‚¡ã‚¤ãƒ«å | å¯å¤‰ |
| `(15/120)` | ç¾åœ¨ãƒšãƒ¼ã‚¸/ç·ãƒšãƒ¼ã‚¸æ•° | 80px |
| `[â‰¡]` | ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³åˆ‡æ›¿ | 40x40px |
| `[è¦‹é–‹ãâ–¾]` | è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ | 100px |
| `[ğŸ”]` | æ¤œç´¢ãƒ‘ãƒãƒ« | 40x40px |
| `[âš™]` | è¨­å®š | 40x40px |

### 2.3 ãƒ„ãƒ¼ãƒ«ãƒãƒ¼

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [å˜ãƒšãƒ¼ã‚¸] [è¦‹é–‹ã] [é€£ç¶š] [100%â–¾] [â†»] [â†º] [ğŸ–¨]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ©Ÿèƒ½:**

- è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ï¼ˆå˜ãƒšãƒ¼ã‚¸/è¦‹é–‹ã/é€£ç¶šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
- ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ + ãƒœã‚¿ãƒ³ï¼‰
- å›è»¢ï¼ˆæ™‚è¨ˆå›ã‚Š/åæ™‚è¨ˆå›ã‚Šï¼‰
- å°åˆ·

---

## 3. PDFå‡¦ç†

### 3.1 PDFèª­ã¿è¾¼ã¿

#### 3.1.1 å‹å®šç¾©

```typescript
interface PDFLoadResult {
  success: boolean;
  pdf: PDFDocument | null;
  error?: string;
}

interface PDFDocument {
  path: string;
  name: string;
  numPages: number;
  info: PDFInfo;
  outline: PDFOutlineNode[];
  fingerprint: string;
}

interface PDFInfo {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  producer?: string;
  creationDate?: Date;
  modificationDate?: Date;
  pdfVersion?: string;
}

interface PDFOutlineNode {
  title: string;
  dest: string | number;
  items: PDFOutlineNode[];
}
```

#### 3.1.2 PDF.jsåˆæœŸåŒ–

```typescript
import * as pdfjsLib from 'pdfjs-dist';

// Workerã®è¨­å®š
pdfjsLib.GlobalWorkerOptions.workerSrc = `pdfjs-dist/build/pdf.worker.js`;

const loadPDF = async (filePath: string): Promise<PDFLoadResult> => {
  try {
    // 1. ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
    const exists = await window.electronAPI.fileExists(filePath);
    if (!exists) {
      return { success: false, pdf: null, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' };
    }

    // 2. ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
    const arrayBuffer = await window.electronAPI.readFile(filePath);

    // 3. PDF.jsã§ãƒ­ãƒ¼ãƒ‰
    const loadingTask = pdfjsLib.getDocument({
      data: arrayBuffer,
      cMapUrl: 'pdfjs-dist/cmaps/',
      cMapPacked: true,
    });

    const pdfDoc = await loadingTask.promise;

    // 4. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—
    const metadata = await pdfDoc.getMetadata();
    const info: PDFInfo = {
      title: metadata.info.Title,
      author: metadata.info.Author,
      subject: metadata.info.Subject,
      keywords: metadata.info.Keywords,
      creator: metadata.info.Creator,
      producer: metadata.info.Producer,
      creationDate: metadata.info.CreationDate ? new Date(metadata.info.CreationDate) : undefined,
      modificationDate: metadata.info.ModDate ? new Date(metadata.info.ModDate) : undefined,
      pdfVersion: metadata.info.PDFFormatVersion,
    };

    // 5. ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å–å¾—
    const outline = await pdfDoc.getOutline();
    const outlineTree = outline ? buildOutlineTree(outline) : [];

    const pdf: PDFDocument = {
      path: filePath,
      name: path.basename(filePath),
      numPages: pdfDoc.numPages,
      info,
      outline: outlineTree,
      fingerprint: pdfDoc.fingerprint,
    };

    return { success: true, pdf };

  } catch (error) {
    console.error('PDF load error:', error);
    return {
      success: false,
      pdf: null,
      error: error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'
    };
  }
};

// ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³éšå±¤æ§‹ç¯‰
const buildOutlineTree = (outline: any[]): PDFOutlineNode[] => {
  return outline.map(item => ({
    title: item.title,
    dest: item.dest,
    items: item.items ? buildOutlineTree(item.items) : [],
  }));
};
```

### 3.2 ãƒšãƒ¼ã‚¸ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°

```typescript
interface RenderOptions {
  scale: number;
  rotation: number;
  viewport?: any;
}

const usePDFPage = (pdfDoc: any, pageNumber: number) => {
  const [page, setPage] = useState<any>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadPage = async () => {
      if (!pdfDoc) return;

      setLoading(true);
      try {
        const pdfPage = await pdfDoc.getPage(pageNumber);
        setPage(pdfPage);
      } catch (error) {
        console.error('Failed to load page:', error);
      } finally {
        setLoading(false);
      }
    };

    loadPage();
  }, [pdfDoc, pageNumber]);

  return { page, loading };
};

const PDFPageCanvas: React.FC<{
  page: any;
  scale: number;
  rotation: number;
}> = ({ page, scale, rotation }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!page || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');
    if (!context) return;

    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨ˆç®—
    const viewport = page.getViewport({ scale, rotation });

    // Canvas ã‚µã‚¤ã‚ºè¨­å®š
    canvas.width = viewport.width;
    canvas.height = viewport.height;

    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const renderContext = {
      canvasContext: context,
      viewport: viewport,
    };

    const renderTask = page.render(renderContext);

    renderTask.promise.then(
      () => {
        console.log('Page rendered successfully');
      },
      (error: any) => {
        console.error('Rendering error:', error);
      }
    );

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => {
      renderTask.cancel();
    };
  }, [page, scale, rotation]);

  return (
    <canvas
      ref={canvasRef}
      className="pdf-page-canvas"
    />
  );
};
```

### 3.3 ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼

```typescript
const PDFTextLayer: React.FC<{
  page: any;
  viewport: any;
}> = ({ page, viewport }) => {
  const textLayerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!page || !textLayerRef.current) return;

    const loadTextContent = async () => {
      const textContent = await page.getTextContent();
      const textLayer = textLayerRef.current;
      if (!textLayer) return;

      // æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
      textLayer.innerHTML = '';

      // PDF.jsã®ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½¿ç”¨
      pdfjsLib.renderTextLayer({
        textContent,
        container: textLayer,
        viewport,
        textDivs: [],
      });
    };

    loadTextContent();
  }, [page, viewport]);

  return (
    <div
      ref={textLayerRef}
      className="pdf-text-layer"
      style={{
        position: 'absolute',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        overflow: 'hidden',
        opacity: 0.2,
        lineHeight: 1,
      }}
    />
  );
};
```

---

## 4. ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³

### 4.1 ãƒšãƒ¼ã‚¸ç®¡ç†

```typescript
interface PDFViewerState {
  currentPage: number;
  numPages: number;
  scale: number;
  rotation: number;
  viewMode: 'single' | 'double' | 'continuous';
  fitMode: 'page' | 'width' | 'auto' | 'custom';
}

const usePageNavigation = (numPages: number) => {
  const [currentPage, setCurrentPage] = useState(1);

  const nextPage = useCallback(() => {
    setCurrentPage(prev => Math.min(prev + 1, numPages));
  }, [numPages]);

  const prevPage = useCallback(() => {
    setCurrentPage(prev => Math.max(prev - 1, 1));
  }, []);

  const goToPage = useCallback((page: number) => {
    setCurrentPage(Math.max(1, Math.min(page, numPages)));
  }, [numPages]);

  const goToFirst = () => goToPage(1);
  const goToLast = () => goToPage(numPages);

  return {
    currentPage,
    nextPage,
    prevPage,
    goToPage,
    goToFirst,
    goToLast,
  };
};
```

### 4.2 ãƒšãƒ¼ã‚¸ã‚µãƒ ãƒã‚¤ãƒ«

```typescript
const PDFThumbnail: React.FC<{
  page: any;
  pageNumber: number;
  isActive: boolean;
  onClick: () => void;
}> = ({ page, pageNumber, isActive, onClick }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!page || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');
    if (!context) return;

    const viewport = page.getViewport({ scale: 0.2 });

    canvas.width = viewport.width;
    canvas.height = viewport.height;

    page.render({
      canvasContext: context,
      viewport: viewport,
    });
  }, [page]);

  return (
    <div
      className={`pdf-thumbnail ${isActive ? 'active' : ''}`}
      onClick={onClick}
    >
      <canvas ref={canvasRef} />
      <div className="thumbnail-number">{pageNumber}</div>
    </div>
  );
};
```

---

## 5. è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰

### 5.1 å˜ãƒšãƒ¼ã‚¸è¡¨ç¤º

```typescript
const SinglePageView: React.FC<{
  pdfDoc: any;
  currentPage: number;
  scale: number;
  rotation: number;
}> = ({ pdfDoc, currentPage, scale, rotation }) => {
  const { page, loading } = usePDFPage(pdfDoc, currentPage);

  if (loading) {
    return <div className="page-loading"><Spinner /></div>;
  }

  return (
    <div className="single-page-view">
      <PDFPageCanvas
        page={page}
        scale={scale}
        rotation={rotation}
      />
    </div>
  );
};
```

### 5.2 è¦‹é–‹ãè¡¨ç¤º

```typescript
const DoublePageView: React.FC<{
  pdfDoc: any;
  currentPage: number;
  scale: number;
  rotation: number;
}> = ({ pdfDoc, currentPage, scale, rotation }) => {
  const { page: leftPage } = usePDFPage(pdfDoc, currentPage);
  const { page: rightPage } = usePDFPage(pdfDoc, currentPage + 1);

  return (
    <div className="double-page-view">
      <div className="page-container left">
        {leftPage && (
          <PDFPageCanvas
            page={leftPage}
            scale={scale}
            rotation={rotation}
          />
        )}
      </div>
      <div className="page-container right">
        {rightPage && (
          <PDFPageCanvas
            page={rightPage}
            scale={scale}
            rotation={rotation}
          />
        )}
      </div>
    </div>
  );
};
```

### 5.3 é€£ç¶šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¡¨ç¤º

```typescript
const ContinuousScrollView: React.FC<{
  pdfDoc: any;
  numPages: number;
  scale: number;
  rotation: number;
}> = ({ pdfDoc, numPages, scale, rotation }) => {
  const [visiblePages, setVisiblePages] = useState<Set<number>>(new Set());
  const containerRef = useRef<HTMLDivElement>(null);

  // Intersection Observer ã§å¯è¦–ãƒšãƒ¼ã‚¸ã‚’è¿½è·¡
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          const pageNum = parseInt(entry.target.getAttribute('data-page') || '1');

          if (entry.isIntersecting) {
            setVisiblePages(prev => new Set(prev).add(pageNum));
          } else {
            setVisiblePages(prev => {
              const next = new Set(prev);
              next.delete(pageNum);
              return next;
            });
          }
        });
      },
      { threshold: 0.1 }
    );

    const pages = containerRef.current?.querySelectorAll('.pdf-page-wrapper');
    pages?.forEach(page => observer.observe(page));

    return () => observer.disconnect();
  }, []);

  return (
    <div className="continuous-scroll-view" ref={containerRef}>
      {Array.from({ length: numPages }, (_, i) => i + 1).map(pageNum => (
        <ContinuousPage
          key={pageNum}
          pdfDoc={pdfDoc}
          pageNumber={pageNum}
          scale={scale}
          rotation={rotation}
          isVisible={visiblePages.has(pageNum)}
        />
      ))}
    </div>
  );
};

const ContinuousPage: React.FC<{
  pdfDoc: any;
  pageNumber: number;
  scale: number;
  rotation: number;
  isVisible: boolean;
}> = ({ pdfDoc, pageNumber, scale, rotation, isVisible }) => {
  const { page, loading } = usePDFPage(pdfDoc, pageNumber);

  return (
    <div className="pdf-page-wrapper" data-page={pageNumber}>
      {isVisible && !loading && page ? (
        <PDFPageCanvas
          page={page}
          scale={scale}
          rotation={rotation}
        />
      ) : (
        <div className="page-placeholder">
          <Skeleton variant="rectangular" width={600} height={800} />
        </div>
      )}
    </div>
  );
};
```

---

## 6. ã‚ºãƒ¼ãƒ ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«

### 6.1 ã‚ºãƒ¼ãƒ åˆ¶å¾¡

```typescript
const useZoom = (fitMode: FitMode) => {
  const [scale, setScale] = useState(1.0);

  const zoomIn = useCallback(() => {
    setScale(prev => Math.min(prev * 1.2, 5.0));
  }, []);

  const zoomOut = useCallback(() => {
    setScale(prev => Math.max(prev / 1.2, 0.1));
  }, []);

  const setZoomLevel = useCallback((level: number) => {
    setScale(Math.max(0.1, Math.min(level, 5.0)));
  }, []);

  const resetZoom = useCallback(() => {
    setScale(1.0);
  }, []);

  // ãƒ•ã‚£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰è¨ˆç®—
  const calculateFitScale = useCallback((
    pageWidth: number,
    pageHeight: number,
    containerWidth: number,
    containerHeight: number
  ) => {
    switch (fitMode) {
      case 'width':
        return containerWidth / pageWidth;
      case 'page':
        return Math.min(
          containerWidth / pageWidth,
          containerHeight / pageHeight
        );
      case 'auto':
        // ãƒšãƒ¼ã‚¸å‘ãã«å¿œã˜ã¦è‡ªå‹•é¸æŠ
        return pageWidth > pageHeight
          ? containerWidth / pageWidth
          : Math.min(containerWidth / pageWidth, containerHeight / pageHeight);
      default:
        return scale;
    }
  }, [fitMode, scale]);

  return {
    scale,
    zoomIn,
    zoomOut,
    setZoomLevel,
    resetZoom,
    calculateFitScale,
  };
};
```

### 6.2 ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UI

```typescript
const ZoomControls: React.FC<{
  scale: number;
  onZoomIn: () => void;
  onZoomOut: () => void;
  onZoomChange: (scale: number) => void;
  fitMode: FitMode;
  onFitModeChange: (mode: FitMode) => void;
}> = ({ scale, onZoomIn, onZoomOut, onZoomChange, fitMode, onFitModeChange }) => {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  const presetZooms = [0.5, 0.75, 1.0, 1.25, 1.5, 2.0, 3.0, 4.0];

  return (
    <div className="zoom-controls">
      <button onClick={onZoomOut} aria-label="ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ">
        <ZoomOutIcon size={20} />
      </button>

      <div className="zoom-level-selector">
        <button onClick={() => setIsDropdownOpen(!isDropdownOpen)}>
          {Math.round(scale * 100)}%
        </button>

        {isDropdownOpen && (
          <div className="zoom-dropdown">
            <button onClick={() => {
              onFitModeChange('page');
              setIsDropdownOpen(false);
            }}>
              ãƒšãƒ¼ã‚¸ã«åˆã‚ã›ã‚‹
            </button>
            <button onClick={() => {
              onFitModeChange('width');
              setIsDropdownOpen(false);
            }}>
              å¹…ã«åˆã‚ã›ã‚‹
            </button>
            <div className="dropdown-divider" />
            {presetZooms.map(zoom => (
              <button
                key={zoom}
                onClick={() => {
                  onZoomChange(zoom);
                  setIsDropdownOpen(false);
                }}
              >
                {zoom * 100}%
              </button>
            ))}
          </div>
        )}
      </div>

      <button onClick={onZoomIn} aria-label="ã‚ºãƒ¼ãƒ ã‚¤ãƒ³">
        <ZoomInIcon size={20} />
      </button>
    </div>
  );
};
```

---

## ãƒ†ã‚­ã‚¹ãƒˆãƒ»æ¤œç´¢ãƒ»ã—ãŠã‚Šãƒ»å°åˆ·ãƒ»çµ±åˆ

---

## 7. ãƒ†ã‚­ã‚¹ãƒˆæ©Ÿèƒ½

### 7.1 ãƒ†ã‚­ã‚¹ãƒˆé¸æŠ

```typescript
const PDFPageWithText: React.FC<{
  page: any;
  scale: number;
  rotation: number;
}> = ({ page, scale, rotation }) => {
  const [viewport, setViewport] = useState<any>(null);

  useEffect(() => {
    if (page) {
      const vp = page.getViewport({ scale, rotation });
      setViewport(vp);
    }
  }, [page, scale, rotation]);

  return (
    <div className="pdf-page-with-text" style={{ position: 'relative' }}>
      {/* Canvas ãƒ¬ã‚¤ãƒ¤ãƒ¼ */}
      <PDFPageCanvas page={page} scale={scale} rotation={rotation} />

      {/* ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ */}
      {viewport && (
        <PDFTextLayer page={page} viewport={viewport} />
      )}
    </div>
  );
};
```

### 7.2 ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢

```typescript
interface SearchResult {
  pageNumber: number;
  matches: TextMatch[];
}

interface TextMatch {
  text: string;
  position: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

const usePDFSearch = (pdfDoc: any) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState<SearchResult[]>([]);
  const [currentMatch, setCurrentMatch] = useState(0);
  const [isSearching, setIsSearching] = useState(false);

  const search = useCallback(async (term: string) => {
    if (!pdfDoc || !term) {
      setResults([]);
      return;
    }

    setIsSearching(true);
    setSearchTerm(term);

    const allResults: SearchResult[] = [];

    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
      const page = await pdfDoc.getPage(pageNum);
      const textContent = await page.getTextContent();

      const pageText = textContent.items
        .map((item: any) => item.str)
        .join(' ');

      // å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„æ¤œç´¢
      const regex = new RegExp(term, 'gi');
      let match;
      const matches: TextMatch[] = [];

      while ((match = regex.exec(pageText)) !== null) {
        // ãƒãƒƒãƒä½ç½®ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        matches.push({
          text: match[0],
          position: {
            x: 0,
            y: 0,
            width: 100,
            height: 20,
          },
        });
      }

      if (matches.length > 0) {
        allResults.push({
          pageNumber: pageNum,
          matches,
        });
      }
    }

    setResults(allResults);
    setCurrentMatch(0);
    setIsSearching(false);
  }, [pdfDoc]);

  const nextMatch = useCallback(() => {
    const totalMatches = results.reduce((sum, r) => sum + r.matches.length, 0);
    setCurrentMatch(prev => (prev + 1) % totalMatches);
  }, [results]);

  const prevMatch = useCallback(() => {
    const totalMatches = results.reduce((sum, r) => sum + r.matches.length, 0);
    setCurrentMatch(prev => (prev - 1 + totalMatches) % totalMatches);
  }, [results]);

  return {
    searchTerm,
    results,
    currentMatch,
    isSearching,
    search,
    nextMatch,
    prevMatch,
  };
};
```

### 7.3 æ¤œç´¢ãƒ‘ãƒãƒ«UI

```typescript
const SearchPanel: React.FC<{
  onSearch: (term: string) => void;
  results: SearchResult[];
  currentMatch: number;
  onNextMatch: () => void;
  onPrevMatch: () => void;
  isSearching: boolean;
  onClose: () => void;
}> = ({ onSearch, results, currentMatch, onNextMatch, onPrevMatch, isSearching, onClose }) => {
  const [searchInput, setSearchInput] = useState('');
  const totalMatches = results.reduce((sum, r) => sum + r.matches.length, 0);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(searchInput);
  };

  return (
    <div className="search-panel">
      <div className="search-header">
        <h4>æ¤œç´¢</h4>
        <button onClick={onClose}>
          <CloseIcon size={16} />
        </button>
      </div>

      <form onSubmit={handleSubmit} className="search-form">
        <input
          type="text"
          value={searchInput}
          onChange={(e) => setSearchInput(e.target.value)}
          placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¤œç´¢..."
          autoFocus
        />
        <button type="submit" disabled={isSearching}>
          <SearchIcon size={16} />
        </button>
      </form>

      {isSearching && (
        <div className="search-status">æ¤œç´¢ä¸­...</div>
      )}

      {!isSearching && results.length > 0 && (
        <div className="search-results">
          <div className="results-header">
            <span>{currentMatch + 1} / {totalMatches} ä»¶</span>
            <div className="navigation-buttons">
              <button onClick={onPrevMatch} aria-label="å‰ã¸">
                <ChevronUpIcon size={16} />
              </button>
              <button onClick={onNextMatch} aria-label="æ¬¡ã¸">
                <ChevronDownIcon size={16} />
              </button>
            </div>
          </div>

          <div className="results-list">
            {results.map(result => (
              <div key={result.pageNumber} className="result-item">
                <div className="result-page">ãƒšãƒ¼ã‚¸ {result.pageNumber}</div>
                <div className="result-matches">
                  {result.matches.length} ä»¶ã®ãƒãƒƒãƒ
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {!isSearching && searchInput && results.length === 0 && (
        <div className="no-results">
          "{searchInput}" ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ
        </div>
      )}
    </div>
  );
};
```

### 7.4 ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ”ãƒ¼

```typescript
const useTextSelection = () => {
  const handleCopy = useCallback(() => {
    const selection = window.getSelection();
    if (!selection || selection.toString().length === 0) return;

    const text = selection.toString();
    navigator.clipboard.writeText(text).then(
      () => {
        // æˆåŠŸé€šçŸ¥
        showNotification({
          type: 'success',
          message: 'ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ',
        });
      },
      (err) => {
        console.error('Failed to copy text:', err);
      }
    );
  }, []);

  useEffect(() => {
    document.addEventListener('copy', handleCopy);
    return () => document.removeEventListener('copy', handleCopy);
  }, [handleCopy]);

  return { handleCopy };
};
```

---

## 8. ã—ãŠã‚Šæ©Ÿèƒ½

### 8.1 ã—ãŠã‚Šç®¡ç†

```typescript
interface PDFBookmark {
  fileId: number;
  page: number;
  scrollPosition: number;
  zoom: number;
  timestamp: number;
}

const useBookmark = (fileId: number) => {
  const [bookmark, setBookmark] = useState<PDFBookmark | null>(null);

  // èª­ã¿è¾¼ã¿
  useEffect(() => {
    const loadBookmark = async () => {
      const saved = await window.electronAPI.getPDFBookmark(fileId);
      if (saved) {
        setBookmark(saved);
      }
    };
    loadBookmark();
  }, [fileId]);

  // ä¿å­˜
  const saveBookmark = useCallback(async (
    page: number,
    scrollPosition: number,
    zoom: number
  ) => {
    const newBookmark: PDFBookmark = {
      fileId,
      page,
      scrollPosition,
      zoom,
      timestamp: Date.now(),
    };

    await window.electronAPI.savePDFBookmark(newBookmark);
    setBookmark(newBookmark);
  }, [fileId]);

  // è‡ªå‹•ä¿å­˜ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
  const autoSave = useCallback(
    debounce((page: number, scrollPosition: number, zoom: number) => {
      saveBookmark(page, scrollPosition, zoom);
    }, 3000),
    [saveBookmark]
  );

  return { bookmark, saveBookmark, autoSave };
};
```

### 8.2 ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ«

```typescript
const OutlinePanel: React.FC<{
  outline: PDFOutlineNode[];
  onNavigate: (dest: string | number) => void;
  isOpen: boolean;
  onClose: () => void;
}> = ({ outline, onNavigate, isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className="outline-panel">
      <div className="panel-header">
        <h3>ç›®æ¬¡</h3>
        <button onClick={onClose}>
          <CloseIcon size={16} />
        </button>
      </div>

      <div className="outline-content">
        {outline.length > 0 ? (
          <OutlineTree nodes={outline} onNavigate={onNavigate} />
        ) : (
          <div className="no-outline">
            ã“ã®PDFã«ã¯ç›®æ¬¡ãŒã‚ã‚Šã¾ã›ã‚“
          </div>
        )}
      </div>
    </div>
  );
};

const OutlineTree: React.FC<{
  nodes: PDFOutlineNode[];
  onNavigate: (dest: string | number) => void;
  level?: number;
}> = ({ nodes, onNavigate, level = 0 }) => {
  return (
    <ul className={`outline-tree level-${level}`}>
      {nodes.map((node, index) => (
        <OutlineItem
          key={index}
          node={node}
          onNavigate={onNavigate}
          level={level}
        />
      ))}
    </ul>
  );
};

const OutlineItem: React.FC<{
  node: PDFOutlineNode;
  onNavigate: (dest: string | number) => void;
  level: number;
}> = ({ node, onNavigate, level }) => {
  const [isExpanded, setIsExpanded] = useState(level < 2);

  const hasChildren = node.items && node.items.length > 0;

  return (
    <li className="outline-item">
      <div className="outline-title">
        {hasChildren && (
          <button
            className="expand-button"
            onClick={() => setIsExpanded(!isExpanded)}
          >
            {isExpanded ? <ChevronDownIcon size={16} /> : <ChevronRightIcon size={16} />}
          </button>
        )}
        <button
          className="title-button"
          onClick={() => onNavigate(node.dest)}
        >
          {node.title}
        </button>
      </div>

      {hasChildren && isExpanded && (
        <OutlineTree
          nodes={node.items}
          onNavigate={onNavigate}
          level={level + 1}
        />
      )}
    </li>
  );
};
```

---

## 9. å°åˆ·æ©Ÿèƒ½

### 9.1 å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°

```typescript
interface PrintOptions {
  pages: 'all' | 'current' | 'range';
  pageRange?: string;  // "1-5, 8, 11-13"
  copies: number;
  orientation: 'portrait' | 'landscape';
}

const PrintDialog: React.FC<{
  numPages: number;
  currentPage: number;
  onPrint: (options: PrintOptions) => void;
  onClose: () => void;
}> = ({ numPages, currentPage, onPrint, onClose }) => {
  const [options, setOptions] = useState<PrintOptions>({
    pages: 'all',
    pageRange: '',
    copies: 1,
    orientation: 'portrait',
  });

  const [rangeError, setRangeError] = useState<string | null>(null);

  const validatePageRange = (range: string): boolean => {
    if (!range) return true;

    const parts = range.split(',');
    for (const part of parts) {
      const trimmed = part.trim();

      if (trimmed.includes('-')) {
        // ç¯„å›²æŒ‡å®š
        const [start, end] = trimmed.split('-').map(s => parseInt(s.trim()));
        if (isNaN(start) || isNaN(end) || start < 1 || end > numPages || start > end) {
          return false;
        }
      } else {
        // å˜ä¸€ãƒšãƒ¼ã‚¸
        const page = parseInt(trimmed);
        if (isNaN(page) || page < 1 || page > numPages) {
          return false;
        }
      }
    }

    return true;
  };

  const handlePrint = () => {
    if (options.pages === 'range') {
      if (!options.pageRange || !validatePageRange(options.pageRange)) {
        setRangeError('æœ‰åŠ¹ãªãƒšãƒ¼ã‚¸ç¯„å›²ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }
    }

    onPrint(options);
    onClose();
  };

  return (
    <div className="print-dialog">
      <div className="dialog-header">
        <h3>å°åˆ·</h3>
        <button onClick={onClose}>
          <CloseIcon size={16} />
        </button>
      </div>

      <div className="dialog-content">
        {/* ãƒšãƒ¼ã‚¸é¸æŠ */}
        <div className="print-section">
          <h4>ãƒšãƒ¼ã‚¸</h4>

          <label className="radio-option">
            <input
              type="radio"
              checked={options.pages === 'all'}
              onChange={() => setOptions(prev => ({ ...prev, pages: 'all' }))}
            />
            ã™ã¹ã¦ (1-{numPages})
          </label>

          <label className="radio-option">
            <input
              type="radio"
              checked={options.pages === 'current'}
              onChange={() => setOptions(prev => ({ ...prev, pages: 'current' }))}
            />
            ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ ({currentPage})
          </label>

          <label className="radio-option">
            <input
              type="radio"
              checked={options.pages === 'range'}
              onChange={() => setOptions(prev => ({ ...prev, pages: 'range' }))}
            />
            ãƒšãƒ¼ã‚¸æŒ‡å®š
          </label>

          {options.pages === 'range' && (
            <div className="page-range-input">
              <input
                type="text"
                value={options.pageRange}
                onChange={(e) => {
                  setOptions(prev => ({ ...prev, pageRange: e.target.value }));
                  setRangeError(null);
                }}
                placeholder="ä¾‹: 1-5, 8, 11-13"
              />
              {rangeError && (
                <div className="error-message">{rangeError}</div>
              )}
            </div>
          )}
        </div>

        {/* éƒ¨æ•° */}
        <div className="print-section">
          <h4>éƒ¨æ•°</h4>
          <input
            type="number"
            min="1"
            max="99"
            value={options.copies}
            onChange={(e) => setOptions(prev => ({ ...prev, copies: parseInt(e.target.value) }))}
          />
        </div>

        {/* å‘ã */}
        <div className="print-section">
          <h4>å‘ã</h4>
          <label className="radio-option">
            <input
              type="radio"
              checked={options.orientation === 'portrait'}
              onChange={() => setOptions(prev => ({ ...prev, orientation: 'portrait' }))}
            />
            ç¸¦
          </label>
          <label className="radio-option">
            <input
              type="radio"
              checked={options.orientation === 'landscape'}
              onChange={() => setOptions(prev => ({ ...prev, orientation: 'landscape' }))}
            />
            æ¨ª
          </label>
        </div>
      </div>

      <div className="dialog-footer">
        <button onClick={onClose}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button className="primary" onClick={handlePrint}>å°åˆ·</button>
      </div>
    </div>
  );
};
```

### 9.2 å°åˆ·å®Ÿè¡Œ

```typescript
const usePrint = (pdfDoc: any) => {
  const printPDF = useCallback(async (options: PrintOptions) => {
    if (!pdfDoc) return;

    // ãƒšãƒ¼ã‚¸ç¯„å›²ã‚’è§£æ
    let pagesToPrint: number[] = [];

    if (options.pages === 'all') {
      pagesToPrint = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
    } else if (options.pages === 'current') {
      pagesToPrint = [options.currentPage];
    } else if (options.pages === 'range' && options.pageRange) {
      pagesToPrint = parsePageRange(options.pageRange);
    }

    // å°åˆ·ç”¨ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
      console.error('Failed to open print window');
      return;
    }

    printWindow.document.write('<html><head><title>å°åˆ·</title></head><body>');

    // å„ãƒšãƒ¼ã‚¸ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    for (const pageNum of pagesToPrint) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1.5 });

      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      const context = canvas.getContext('2d');
      if (!context) continue;

      await page.render({
        canvasContext: context,
        viewport: viewport,
      }).promise;

      // Canvas ã‚’ç”»åƒã¨ã—ã¦è¿½åŠ 
      const imgData = canvas.toDataURL('image/png');
      printWindow.document.write(`<img src="${imgData}" style="page-break-after: always;" />`);
    }

    printWindow.document.write('</body></html>');
    printWindow.document.close();

    // å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
    printWindow.focus();
    printWindow.print();

  }, [pdfDoc]);

  return { printPDF };
};

// ãƒšãƒ¼ã‚¸ç¯„å›²ã®ãƒ‘ãƒ¼ã‚¹
const parsePageRange = (range: string): number[] => {
  const pages: number[] = [];
  const parts = range.split(',');

  for (const part of parts) {
    const trimmed = part.trim();

    if (trimmed.includes('-')) {
      const [start, end] = trimmed.split('-').map(s => parseInt(s.trim()));
      for (let i = start; i <= end; i++) {
        pages.push(i);
      }
    } else {
      pages.push(parseInt(trimmed));
    }
  }

  return [...new Set(pages)].sort((a, b) => a - b);
};
```

---

## 10. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ

```typescript
const usePDFKeyboard = (
  navigation: ReturnType<typeof usePageNavigation>,
  actions: PDFViewerActions
) => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // ä¿®é£¾ã‚­ãƒ¼ãƒã‚§ãƒƒã‚¯
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'f':
            e.preventDefault();
            actions.openSearch();
            break;
          case 'p':
            e.preventDefault();
            actions.openPrint();
            break;
          case '+':
          case '=':
            e.preventDefault();
            actions.zoomIn();
            break;
          case '-':
            e.preventDefault();
            actions.zoomOut();
            break;
          case '0':
            e.preventDefault();
            actions.resetZoom();
            break;
        }
        return;
      }

      switch (e.key) {
        // ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        case 'ArrowRight':
        case 'PageDown':
        case 'j':
          e.preventDefault();
          navigation.nextPage();
          break;

        case 'ArrowLeft':
        case 'PageUp':
        case 'k':
          e.preventDefault();
          navigation.prevPage();
          break;

        case 'Home':
          e.preventDefault();
          navigation.goToFirst();
          break;

        case 'End':
          e.preventDefault();
          navigation.goToLast();
          break;

        // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰
        case '1':
          e.preventDefault();
          actions.setViewMode('single');
          break;

        case '2':
          e.preventDefault();
          actions.setViewMode('double');
          break;

        case '3':
          e.preventDefault();
          actions.setViewMode('continuous');
          break;

        // å›è»¢
        case 'r':
          e.preventDefault();
          actions.rotateClockwise();
          break;

        case 'R':
          if (e.shiftKey) {
            e.preventDefault();
            actions.rotateCounterClockwise();
          }
          break;

        // ãã®ä»–
        case 'f':
          e.preventDefault();
          actions.toggleFullscreen();
          break;

        case 'o':
          e.preventDefault();
          actions.toggleOutline();
          break;

        case 'Escape':
          if (actions.isFullscreen) {
            actions.exitFullscreen();
          } else {
            actions.closeViewer();
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [navigation, actions]);
};
```

---

## 11. çµ±åˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 11.1 ãƒ¡ã‚¤ãƒ³PDFãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼

```typescript
const PDFViewer: React.FC<{
  file: FileInfo;
  onClose: () => void;
}> = ({ file, onClose }) => {
  // PDFèª­ã¿è¾¼ã¿
  const [pdfDoc, setPdfDoc] = useState<any>(null);
  const [pdfInfo, setPdfInfo] = useState<PDFDocument | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼çŠ¶æ…‹
  const [viewerState, setViewerState] = useState<PDFViewerState>({
    currentPage: 1,
    numPages: 0,
    scale: 1.0,
    rotation: 0,
    viewMode: 'single',
    fitMode: 'page',
  });

  // UIçŠ¶æ…‹
  const [showOutline, setShowOutline] = useState(false);
  const [showSearch, setShowSearch] = useState(false);
  const [showPrint, setShowPrint] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  // PDFåˆæœŸåŒ–
  useEffect(() => {
    const init = async () => {
      setLoading(true);
      const result = await loadPDF(file.file_path);

      if (result.success && result.pdf) {
        setPdfInfo(result.pdf);

        // PDF.jsãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
        const arrayBuffer = await window.electronAPI.readFile(file.file_path);
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        const doc = await loadingTask.promise;

        setPdfDoc(doc);
        setViewerState(prev => ({ ...prev, numPages: doc.numPages }));
      } else {
        setError(result.error || 'PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      setLoading(false);
    };

    init();
  }, [file]);

  // ãƒšãƒ¼ã‚¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
  const navigation = usePageNavigation(viewerState.numPages);

  // ã‚ºãƒ¼ãƒ 
  const zoom = useZoom(viewerState.fitMode);

  // æ¤œç´¢
  const search = usePDFSearch(pdfDoc);

  // ã—ãŠã‚Š
  const { bookmark, saveBookmark, autoSave } = useBookmark(file.id);

  // å°åˆ·
  const { printPDF } = usePrint(pdfDoc);

  // è‡ªå‹•ä¿å­˜
  useEffect(() => {
    autoSave(
      navigation.currentPage,
      window.scrollY,
      zoom.scale
    );
  }, [navigation.currentPage, zoom.scale, autoSave]);

  // ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  const actions: PDFViewerActions = {
    nextPage: navigation.nextPage,
    prevPage: navigation.prevPage,
    goToPage: navigation.goToPage,
    goToFirst: navigation.goToFirst,
    goToLast: navigation.goToLast,

    zoomIn: zoom.zoomIn,
    zoomOut: zoom.zoomOut,
    resetZoom: zoom.resetZoom,
    setZoomLevel: zoom.setZoomLevel,

    setViewMode: (mode) => {
      setViewerState(prev => ({ ...prev, viewMode: mode }));
    },

    setFitMode: (mode) => {
      setViewerState(prev => ({ ...prev, fitMode: mode }));
    },

    rotateClockwise: () => {
      setViewerState(prev => ({
        ...prev,
        rotation: (prev.rotation + 90) % 360,
      }));
    },

    rotateCounterClockwise: () => {
      setViewerState(prev => ({
        ...prev,
        rotation: (prev.rotation - 90 + 360) % 360,
      }));
    },

    toggleFullscreen: () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        setIsFullscreen(true);
      } else {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    },

    exitFullscreen: () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    },

    toggleOutline: () => setShowOutline(prev => !prev),
    openSearch: () => setShowSearch(true),
    openPrint: () => setShowPrint(true),

    saveBookmark: () => saveBookmark(
      navigation.currentPage,
      window.scrollY,
      zoom.scale
    ),

    closeViewer: () => {
      saveBookmark(navigation.currentPage, window.scrollY, zoom.scale);
      onClose();
    },

    isFullscreen,
  };

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
  usePDFKeyboard(navigation, actions);

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
  if (loading) {
    return (
      <div className="viewer-loading">
        <Spinner size={64} />
        <p>PDFã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</p>
      </div>
    );
  }

  // ã‚¨ãƒ©ãƒ¼
  if (error || !pdfDoc || !pdfInfo) {
    return (
      <div className="viewer-error">
        <AlertTriangleIcon size={64} />
        <h3>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h3>
        <p>{error}</p>
        <button onClick={onClose}>é–‰ã˜ã‚‹</button>
      </div>
    );
  }

  // ã—ãŠã‚Šå¾©å¸°
  const [showBookmarkResume, setShowBookmarkResume] = useState(!!bookmark);

  return (
    <div className="pdf-viewer" data-fullscreen={isFullscreen}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      {!isFullscreen && (
        <ViewerHeader
          fileName={pdfInfo.name}
          currentPage={navigation.currentPage}
          numPages={viewerState.numPages}
          onClose={onClose}
          onToggleOutline={actions.toggleOutline}
          onOpenSearch={actions.openSearch}
        />
      )}

      <div className="viewer-layout">
        {/* ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ« */}
        {showOutline && (
          <OutlinePanel
            outline={pdfInfo.outline}
            onNavigate={(dest) => {
              if (typeof dest === 'number') {
                navigation.goToPage(dest);
              }
            }}
            isOpen={showOutline}
            onClose={() => setShowOutline(false)}
          />
        )}

        {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
        <div className="viewer-main">
          {/* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */}
          <Toolbar
            viewMode={viewerState.viewMode}
            onViewModeChange={actions.setViewMode}
            scale={zoom.scale}
            onZoomIn={zoom.zoomIn}
            onZoomOut={zoom.zoomOut}
            onZoomChange={zoom.setZoomLevel}
            fitMode={viewerState.fitMode}
            onFitModeChange={actions.setFitMode}
            rotation={viewerState.rotation}
            onRotateClockwise={actions.rotateClockwise}
            onRotateCounterClockwise={actions.rotateCounterClockwise}
            onPrint={actions.openPrint}
          />

          {/* PDFè¡¨ç¤ºã‚¨ãƒªã‚¢ */}
          <div className="pdf-content">
            {viewerState.viewMode === 'single' && (
              <SinglePageView
                pdfDoc={pdfDoc}
                currentPage={navigation.currentPage}
                scale={zoom.scale}
                rotation={viewerState.rotation}
              />
            )}

            {viewerState.viewMode === 'double' && (
              <DoublePageView
                pdfDoc={pdfDoc}
                currentPage={navigation.currentPage}
                scale={zoom.scale}
                rotation={viewerState.rotation}
              />
            )}

            {viewerState.viewMode === 'continuous' && (
              <ContinuousScrollView
                pdfDoc={pdfDoc}
                numPages={viewerState.numPages}
                scale={zoom.scale}
                rotation={viewerState.rotation}
              />
            )}
          </div>

          {/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */}
          <StatusBar
            currentPage={navigation.currentPage}
            numPages={viewerState.numPages}
            scale={zoom.scale}
            searchResults={search.results}
          />
        </div>

        {/* æ¤œç´¢ãƒ‘ãƒãƒ« */}
        {showSearch && (
          <SearchPanel
            onSearch={search.search}
            results={search.results}
            currentMatch={search.currentMatch}
            onNextMatch={search.nextMatch}
            onPrevMatch={search.prevMatch}
            isSearching={search.isSearching}
            onClose={() => setShowSearch(false)}
          />
        )}
      </div>

      {/* å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
      {showPrint && (
        <PrintDialog
          numPages={viewerState.numPages}
          currentPage={navigation.currentPage}
          onPrint={printPDF}
          onClose={() => setShowPrint(false)}
        />
      )}

      {/* ã—ãŠã‚Šå¾©å¸° */}
      {showBookmarkResume && bookmark && (
        <BookmarkResume
          bookmark={bookmark}
          onResume={() => {
            navigation.goToPage(bookmark.page);
            zoom.setZoomLevel(bookmark.zoom);
            setShowBookmarkResume(false);
          }}
          onStartOver={() => {
            navigation.goToFirst();
            setShowBookmarkResume(false);
          }}
        />
      )}
    </div>
  );
};

export default PDFViewer;
```

### 11.2 å‹å®šç¾©

```typescript
// types.ts
export interface PDFViewerActions {
  nextPage: () => void;
  prevPage: () => void;
  goToPage: (page: number) => void;
  goToFirst: () => void;
  goToLast: () => void;
  zoomIn: () => void;
  zoomOut: () => void;
  resetZoom: () => void;
  setZoomLevel: (level: number) => void;
  setViewMode: (mode: 'single' | 'double' | 'continuous') => void;
  setFitMode: (mode: FitMode) => void;
  rotateClockwise: () => void;
  rotateCounterClockwise: () => void;
  toggleFullscreen: () => void;
  exitFullscreen: () => void;
  toggleOutline: () => void;
  openSearch: () => void;
  openPrint: () => void;
  saveBookmark: () => void;
  closeViewer: () => void;
  isFullscreen: boolean;
}
```

---
