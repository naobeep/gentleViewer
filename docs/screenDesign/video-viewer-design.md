# å‹•ç”»ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ è©³ç´°è¨­è¨ˆæ›¸

## æ¦‚è¦ãƒ»ç”»é¢æ§‹æˆãƒ»å‹•ç”»å‡¦ç†

---

## 1. ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼æ¦‚è¦

### 1.1 ç›®çš„

ã•ã¾ã–ã¾ãªå½¢å¼ã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¿«é©ã«å†ç”Ÿãƒ»ç®¡ç†ã§ãã‚‹çµ±åˆå‹•ç”»ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã€‚

### 1.2 ä¸»è¦æ©Ÿèƒ½

- **å¤šå½¢å¼å¯¾å¿œ**: MP4, WebM, OGV, MKV, AVIå¯¾å¿œ
- **ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆå†ç”Ÿ**: ã‚¿ã‚°ã§æŠ½å‡ºã—ãŸå‹•ç”»ã‚’é€£ç¶šå†ç”Ÿ
- **å†ç”Ÿåˆ¶å¾¡**: å†ç”Ÿ/ä¸€æ™‚åœæ­¢ã€ã‚·ãƒ¼ã‚¯ã€é€Ÿåº¦å¤‰æ›´
- **å­—å¹•å¯¾å¿œ**: å¤–éƒ¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆSRT, VTTï¼‰
- **ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ**: ä»»æ„ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
- **ãƒ”ã‚¯ãƒãƒ£ãƒ¼ã‚¤ãƒ³ãƒ”ã‚¯ãƒãƒ£ãƒ¼**: ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ä¸Šã«å¸¸ã«è¡¨ç¤º
- **ãƒãƒ£ãƒ—ã‚¿ãƒ¼ç®¡ç†**: ã‚·ãƒ¼ãƒ³ãƒãƒ¼ã‚«ãƒ¼è¨­å®š
- **è¦–è´å±¥æ­´**: å†ç”Ÿä½ç½®ã®è‡ªå‹•è¨˜æ†¶

### 1.3 å¯¾å¿œå½¢å¼

**å‹•ç”»ã‚³ãƒ³ãƒ†ãƒŠ:**

- MP4 (.mp4)
- WebM (.webm)
- OGV (.ogv)
- MKV (.mkv) (Phase 1 - åŸºæœ¬å¯¾å¿œï¼‰
- AVI (.avi) (Phase 2)

**ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯:**

- æ˜ åƒ: H.264, H.265/HEVC, VP8, VP9, AV1
- éŸ³å£°: AAC, MP3, Opus, Vorbis

**å­—å¹•:**

- SubRip (.srt)
- WebVTT (.vtt)
- ASS/SSA (.ass, .ssa) (Phase 2)

---

## 2. ç”»é¢æ§‹æˆ

### 2.1 å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ãƒ˜ãƒƒãƒ€ãƒ¼ (é«˜ã•: 56px, è‡ªå‹•éè¡¨ç¤º)                             â”‚
â”‚ [â—€ï¸] video_001.mp4 (5/12) [ğŸ“‹] [âš™ï¸] [â”€] [â–¡] [Ã—]              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚                                                              â”‚
â”‚                       å‹•ç”»è¡¨ç¤ºã‚¨ãƒªã‚¢                          â”‚
â”‚                    (16:9 ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”)                       â”‚
â”‚                                                              â”‚
â”‚                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ (é«˜ã•: 80px, è‡ªå‹•éè¡¨ç¤º)                     â”‚
â”‚ [â–¶ï¸] [â®ï¸] [â­ï¸] [â”â”â”â—â”â”â”â”â”â”â”] 12:34 / 45:67 [ğŸ”Š] [âš™ï¸] [â›¶]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ãƒ˜ãƒƒãƒ€ãƒ¼è©³ç´°

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â—€ï¸] video_001.mp4 (5/12) [ğŸ“‹] [âš™ï¸] [â”€] [â–¡] [Ã—]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è¦ç´ :**

| è¦ç´  | èª¬æ˜ | ã‚µã‚¤ã‚º |
|-----|------|-------|
| `[â—€ï¸]` | å‰ã®å‹•ç”» | 40x40px |
| ãƒ•ã‚¡ã‚¤ãƒ«å | ç¾åœ¨ã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«å | å¯å¤‰ |
| `(5/12)` | ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆå†…ä½ç½® | 80px |
| `[ğŸ“‹]` | ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆãƒ‘ãƒãƒ«åˆ‡æ›¿ | 40x40px |
| `[âš™ï¸]` | è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ | 40x40px |
| `[â”€]` `[â–¡]` `[Ã—]` | ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ“ä½œ | 40x40px Ã— 3 |

### 2.3 ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼è©³ç´°

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«                                              â”‚
â”‚ [â–¶ï¸] [â®ï¸] [â­ï¸] [â”â”â”â—â”â”â”â”â”â”â”] 12:34 / 45:67 [ğŸ”Š] [âš™ï¸] [â›¶]   â”‚
â”‚                                                              â”‚
â”‚ è¿½åŠ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆå±•é–‹æ™‚ï¼‰                                    â”‚
â”‚ [å­—å¹•] [é€Ÿåº¦: 1.0x] [ç”»è³ª] [ğŸ“·] [ğŸ”–]                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åŸºæœ¬ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«:**

| è¦ç´  | èª¬æ˜ |
|-----|------|
| `[â–¶ï¸]` / `[â¸ï¸]` | å†ç”Ÿ/ä¸€æ™‚åœæ­¢ |
| `[â®ï¸]` | å‰ã®å‹•ç”» |
| `[â­ï¸]` | æ¬¡ã®å‹•ç”» |
| ã‚·ãƒ¼ã‚¯ãƒãƒ¼ | å†ç”Ÿä½ç½®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ |
| æ™‚é–“è¡¨ç¤º | ç¾åœ¨æ™‚åˆ» / ç·æ™‚é–“ |
| `[ğŸ”Š]` | éŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« |
| `[âš™ï¸]` | è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼å±•é–‹ |
| `[â›¶]` | å…¨ç”»é¢åˆ‡æ›¿ |

**æ‹¡å¼µã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«:**

| è¦ç´  | èª¬æ˜ |
|-----|------|
| `[å­—å¹•]` | å­—å¹•ON/OFFãƒ»é¸æŠ |
| `[é€Ÿåº¦]` | å†ç”Ÿé€Ÿåº¦å¤‰æ›´ |
| `[ç”»è³ª]` | å“è³ªè¨­å®š |
| `[ğŸ“·]` | ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ |
| `[ğŸ”–]` | ãƒãƒ£ãƒ—ã‚¿ãƒ¼ãƒãƒ¼ã‚¯è¿½åŠ  |

---

## 3. å‹•ç”»å‡¦ç†

### 3.1 å‹•ç”»èª­ã¿è¾¼ã¿

#### 3.1.1 å‹å®šç¾©

```typescript
interface VideoLoadResult {
  success: boolean;
  video: VideoInfo | null;
  error?: string;
}

interface VideoInfo {
  path: string;
  name: string;
  duration: number;        // ç§’
  width: number;
  height: number;
  aspectRatio: number;
  codec_video: string;
  codec_audio: string;
  bitrate: number;         // kbps
  framerate: number;
  size: number;            // ãƒã‚¤ãƒˆ
  hasAudio: boolean;
  hasVideo: boolean;
  thumbnailPath?: string;
  subtitleTracks: SubtitleTrack[];
  audioTracks: AudioTrack[];
}

interface SubtitleTrack {
  id: number;
  language: string;
  label: string;
  format: 'srt' | 'vtt' | 'ass';
  path?: string;           // å¤–éƒ¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«
  isEmbedded: boolean;     // åŸ‹ã‚è¾¼ã¿å­—å¹•
}

interface AudioTrack {
  id: number;
  language: string;
  label: string;
  channels: number;
  codec: string;
}
```

#### 3.1.2 èª­ã¿è¾¼ã¿ãƒ•ãƒ­ãƒ¼

```typescript
const loadVideo = async (filePath: string): Promise<VideoLoadResult> => {
  try {
    // 1. ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
    const exists = await window.electronAPI.fileExists(filePath);
    if (!exists) {
      return { success: false, video: null, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' };
    }

    // 2. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆffprobeä½¿ç”¨ï¼‰
    const metadata = await window.electronAPI.getVideoMetadata(filePath);

    // 3. ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯å¯¾å¿œãƒã‚§ãƒƒã‚¯
    const isSupported = checkCodecSupport(
      metadata.codec_video,
      metadata.codec_audio
    );

    if (!isSupported) {
      return {
        success: false,
        video: null,
        error: `éå¯¾å¿œã®ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯: ${metadata.codec_video}/${metadata.codec_audio}`
      };
    }

    // 4. å­—å¹•ãƒˆãƒ©ãƒƒã‚¯æ¤œå‡º
    const subtitleTracks = await detectSubtitleTracks(filePath, metadata);

    // 5. éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯æ¤œå‡º
    const audioTracks = metadata.audioStreams.map((stream, index) => ({
      id: index,
      language: stream.language || 'unknown',
      label: stream.title || `Audio ${index + 1}`,
      channels: stream.channels,
      codec: stream.codec,
    }));

    // 6. ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ
    const thumbnailPath = await generateVideoThumbnail(filePath);

    const video: VideoInfo = {
      path: filePath,
      name: path.basename(filePath),
      duration: metadata.duration,
      width: metadata.width,
      height: metadata.height,
      aspectRatio: metadata.width / metadata.height,
      codec_video: metadata.codec_video,
      codec_audio: metadata.codec_audio,
      bitrate: metadata.bitrate,
      framerate: metadata.framerate,
      size: metadata.size,
      hasAudio: audioTracks.length > 0,
      hasVideo: !!metadata.videoStream,
      thumbnailPath,
      subtitleTracks,
      audioTracks,
    };

    return { success: true, video };

  } catch (error) {
    console.error('Video load error:', error);
    return {
      success: false,
      video: null,
      error: error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'
    };
  }
};
```

### 3.2 ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯å¯¾å¿œãƒã‚§ãƒƒã‚¯

```typescript
const SUPPORTED_VIDEO_CODECS = [
  'h264', 'avc1',           // H.264
  'h265', 'hevc', 'hvc1',   // H.265
  'vp8',                    // VP8
  'vp9',                    // VP9
  'av1', 'av01',            // AV1
];

const SUPPORTED_AUDIO_CODECS = [
  'aac', 'mp4a',            // AAC
  'mp3',                    // MP3
  'opus',                   // Opus
  'vorbis',                 // Vorbis
];

const checkCodecSupport = (
  videoCodec: string,
  audioCodec: string
): boolean => {
  const videoSupported = SUPPORTED_VIDEO_CODECS.some(codec =>
    videoCodec.toLowerCase().includes(codec)
  );

  const audioSupported = !audioCodec || SUPPORTED_AUDIO_CODECS.some(codec =>
    audioCodec.toLowerCase().includes(codec)
  );

  return videoSupported && audioSupported;
};

// ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚µãƒãƒ¼ãƒˆç¢ºèª
const canPlayNatively = (mimeType: string, codecs?: string): boolean => {
  const video = document.createElement('video');
  const fullType = codecs ? `${mimeType}; codecs="${codecs}"` : mimeType;

  const support = video.canPlayType(fullType);
  return support === 'probably' || support === 'maybe';
};
```

### 3.3 ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—

**ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ (fluent-ffmpegä½¿ç”¨):**

```typescript
// main/services/video-metadata.ts
import ffmpeg from 'fluent-ffmpeg';
import { promisify } from 'util';

interface FFprobeResult {
  format: {
    duration: number;
    bit_rate: number;
    size: number;
  };
  streams: Array<{
    codec_type: 'video' | 'audio' | 'subtitle';
    codec_name: string;
    width?: number;
    height?: number;
    r_frame_rate?: string;
    channels?: number;
    channel_layout?: string;
    tags?: {
      language?: string;
      title?: string;
    };
  }>;
}

export const getVideoMetadata = async (filePath: string): Promise<VideoMetadata> => {
  return new Promise((resolve, reject) => {
    ffmpeg.ffprobe(filePath, (err, data: FFprobeResult) => {
      if (err) {
        reject(err);
        return;
      }

      const videoStream = data.streams.find(s => s.codec_type === 'video');
      const audioStreams = data.streams.filter(s => s.codec_type === 'audio');
      const subtitleStreams = data.streams.filter(s => s.codec_type === 'subtitle');

      if (!videoStream) {
        reject(new Error('No video stream found'));
        return;
      }

      // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
      const framerateParts = videoStream.r_frame_rate?.split('/') || ['30', '1'];
      const framerate = parseInt(framerateParts[0]) / parseInt(framerateParts[1]);

      resolve({
        duration: data.format.duration,
        width: videoStream.width || 0,
        height: videoStream.height || 0,
        codec_video: videoStream.codec_name,
        codec_audio: audioStreams[0]?.codec_name || '',
        bitrate: Math.round(data.format.bit_rate / 1000), // kbps
        framerate,
        size: parseInt(data.format.size),
        videoStream,
        audioStreams,
        subtitleStreams,
      });
    });
  });
};
```

### 3.4 ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ

```typescript
// main/services/thumbnail.ts
export const generateVideoThumbnail = async (
  videoPath: string,
  options: {
    timestamp?: number; // ç§’
    width?: number;
    height?: number;
  } = {}
): Promise<string> => {
  const { timestamp = 5, width = 320, height = 180 } = options;

  const thumbnailDir = path.join(app.getPath('userData'), 'cache', 'thumbnails');
  await fs.promises.mkdir(thumbnailDir, { recursive: true });

  const outputPath = path.join(
    thumbnailDir,
    `${createHash('md5').update(videoPath).digest('hex')}_${timestamp}.jpg`
  );

  // ã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
  if (await fileExists(outputPath)) {
    return outputPath;
  }

  return new Promise((resolve, reject) => {
    ffmpeg(videoPath)
      .screenshots({
        timestamps: [timestamp],
        filename: path.basename(outputPath),
        folder: thumbnailDir,
        size: `${width}x${height}`,
      })
      .on('end', () => resolve(outputPath))
      .on('error', reject);
  });
};
```

### 3.5 å­—å¹•æ¤œå‡º

```typescript
const detectSubtitleTracks = async (
  videoPath: string,
  metadata: VideoMetadata
): Promise<SubtitleTrack[]> => {
  const tracks: SubtitleTrack[] = [];

  // 1. åŸ‹ã‚è¾¼ã¿å­—å¹•
  metadata.subtitleStreams.forEach((stream, index) => {
    tracks.push({
      id: index,
      language: stream.tags?.language || 'unknown',
      label: stream.tags?.title || `Subtitle ${index + 1}`,
      format: 'vtt', // å¤‰æ›ãŒå¿…è¦
      isEmbedded: true,
    });
  });

  // 2. å¤–éƒ¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º
  const videoDir = path.dirname(videoPath);
  const videoName = path.basename(videoPath, path.extname(videoPath));

  const subtitleExtensions = ['.srt', '.vtt', '.ass', '.ssa'];

  for (const ext of subtitleExtensions) {
    const subtitlePath = path.join(videoDir, videoName + ext);

    if (await fileExists(subtitlePath)) {
      tracks.push({
        id: tracks.length,
        language: 'unknown', // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ¨æ¸¬å¯èƒ½
        label: path.basename(subtitlePath),
        format: ext.slice(1) as 'srt' | 'vtt' | 'ass',
        path: subtitlePath,
        isEmbedded: false,
      });
    }
  }

  return tracks;
};
```

---

## 4. å‹•ç”»å†ç”Ÿåˆ¶å¾¡

### 4.1 Videoè¦ç´ ã®ç®¡ç†

```typescript
const VideoPlayer: React.FC<{
  video: VideoInfo;
  onEnded: () => void;
  onError: (error: Error) => void;
}> = ({ video, onEnded, onError }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1.0);
  const [muted, setMuted] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1.0);

  // å‹•ç”»èª­ã¿è¾¼ã¿
  useEffect(() => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    videoElement.src = `file://${video.path}`;
    videoElement.load();
  }, [video.path]);

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  useEffect(() => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    const handleLoadedMetadata = () => {
      setDuration(videoElement.duration);
    };

    const handleTimeUpdate = () => {
      setCurrentTime(videoElement.currentTime);
    };

    const handleEnded = () => {
      setIsPlaying(false);
      onEnded();
    };

    const handleError = () => {
      onError(new Error('Video playback error'));
    };

    videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);
    videoElement.addEventListener('timeupdate', handleTimeUpdate);
    videoElement.addEventListener('ended', handleEnded);
    videoElement.addEventListener('error', handleError);

    return () => {
      videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);
      videoElement.removeEventListener('timeupdate', handleTimeUpdate);
      videoElement.removeEventListener('ended', handleEnded);
      videoElement.removeEventListener('error', handleError);
    };
  }, [onEnded, onError]);

  // å†ç”Ÿ/ä¸€æ™‚åœæ­¢
  const togglePlay = useCallback(() => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    if (isPlaying) {
      videoElement.pause();
    } else {
      videoElement.play();
    }
    setIsPlaying(!isPlaying);
  }, [isPlaying]);

  // ã‚·ãƒ¼ã‚¯
  const seek = useCallback((time: number) => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    videoElement.currentTime = Math.max(0, Math.min(time, duration));
  }, [duration]);

  // éŸ³é‡å¤‰æ›´
  const changeVolume = useCallback((newVolume: number) => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    const clampedVolume = Math.max(0, Math.min(1, newVolume));
    videoElement.volume = clampedVolume;
    setVolume(clampedVolume);
  }, []);

  // ãƒŸãƒ¥ãƒ¼ãƒˆåˆ‡æ›¿
  const toggleMute = useCallback(() => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    videoElement.muted = !muted;
    setMuted(!muted);
  }, [muted]);

  // å†ç”Ÿé€Ÿåº¦å¤‰æ›´
  const changePlaybackRate = useCallback((rate: number) => {
    const videoElement = videoRef.current;
    if (!videoElement) return;

    videoElement.playbackRate = rate;
    setPlaybackRate(rate);
  }, []);

  return (
    <div className="video-player">
      <video
        ref={videoRef}
        className="video-element"
        playsInline
        preload="metadata"
      />
      <VideoControls
        isPlaying={isPlaying}
        currentTime={currentTime}
        duration={duration}
        volume={volume}
        muted={muted}
        playbackRate={playbackRate}
        onPlayPause={togglePlay}
        onSeek={seek}
        onVolumeChange={changeVolume}
        onMuteToggle={toggleMute}
        onPlaybackRateChange={changePlaybackRate}
      />
    </div>
  );
};
```

---

## UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ»å­—å¹•ãƒ»ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ

---

## 5. ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼UI

### 5.1 å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«

```typescript
const PlaybackControls: React.FC<{
  isPlaying: boolean;
  onPlayPause: () => void;
  onPrevious: () => void;
  onNext: () => void;
  hasPrevious: boolean;
  hasNext: boolean;
}> = ({ isPlaying, onPlayPause, onPrevious, onNext, hasPrevious, hasNext }) => {
  return (
    <div className="playback-controls">
      <button
        className="control-button previous"
        onClick={onPrevious}
        disabled={!hasPrevious}
        aria-label="å‰ã®å‹•ç”»"
      >
        <SkipBackIcon size={24} />
      </button>

      <button
        className="control-button play-pause"
        onClick={onPlayPause}
        aria-label={isPlaying ? 'ä¸€æ™‚åœæ­¢' : 'å†ç”Ÿ'}
      >
        {isPlaying ? <PauseIcon size={32} /> : <PlayIcon size={32} />}
      </button>

      <button
        className="control-button next"
        onClick={onNext}
        disabled={!hasNext}
        aria-label="æ¬¡ã®å‹•ç”»"
      >
        <SkipForwardIcon size={24} />
      </button>
    </div>
  );
};
```

### 5.2 ã‚·ãƒ¼ã‚¯ãƒãƒ¼

```typescript
const SeekBar: React.FC<{
  currentTime: number;
  duration: number;
  buffered: TimeRanges | null;
  onSeek: (time: number) => void;
  chapters?: Chapter[];
}> = ({ currentTime, duration, buffered, onSeek, chapters = [] }) => {
  const [isSeeking, setIsSeeking] = useState(false);
  const [seekPosition, setSeekPosition] = useState(0);
  const [hoverTime, setHoverTime] = useState<number | null>(null);
  const barRef = useRef<HTMLDivElement>(null);

  // ã‚·ãƒ¼ã‚¯å‡¦ç†
  const handleSeek = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const bar = barRef.current;
    if (!bar) return;

    const rect = bar.getBoundingClientRect();
    const position = (e.clientX - rect.left) / rect.width;
    const time = position * duration;

    onSeek(time);
  }, [duration, onSeek]);

  // ãƒ‰ãƒ©ãƒƒã‚°ã‚·ãƒ¼ã‚¯
  const handleMouseDown = (e: React.MouseEvent) => {
    setIsSeeking(true);
    handleSeek(e);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isSeeking) {
      const bar = barRef.current;
      if (!bar) return;

      const rect = bar.getBoundingClientRect();
      const position = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      setSeekPosition(position);
    }
  };

  const handleMouseUp = () => {
    if (isSeeking) {
      onSeek(seekPosition * duration);
      setIsSeeking(false);
    }
  };

  useEffect(() => {
    if (isSeeking) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);

      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isSeeking, seekPosition]);

  // ãƒ›ãƒãƒ¼æ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚é–“è¡¨ç¤º
  const handleMouseHover = (e: React.MouseEvent<HTMLDivElement>) => {
    const bar = barRef.current;
    if (!bar) return;

    const rect = bar.getBoundingClientRect();
    const position = (e.clientX - rect.left) / rect.width;
    const time = position * duration;

    setHoverTime(time);
  };

  const progress = (currentTime / duration) * 100;

  // ãƒãƒƒãƒ•ã‚¡æ¸ˆã¿ç¯„å›²ã®è¨ˆç®—
  const getBufferedRanges = (): Array<{ start: number; end: number }> => {
    if (!buffered) return [];

    const ranges: Array<{ start: number; end: number }> = [];
    for (let i = 0; i < buffered.length; i++) {
      ranges.push({
        start: (buffered.start(i) / duration) * 100,
        end: (buffered.end(i) / duration) * 100,
      });
    }
    return ranges;
  };

  return (
    <div className="seek-bar-container">
      <div
        ref={barRef}
        className="seek-bar"
        onMouseDown={handleSeek}
        onMouseMove={handleMouseHover}
        onMouseLeave={() => setHoverTime(null)}
      >
        {/* ãƒãƒƒãƒ•ã‚¡æ¸ˆã¿ç¯„å›² */}
        {getBufferedRanges().map((range, index) => (
          <div
            key={index}
            className="buffered-range"
            style={{
              left: `${range.start}%`,
              width: `${range.end - range.start}%`,
            }}
          />
        ))}

        {/* å†ç”Ÿæ¸ˆã¿ç¯„å›² */}
        <div className="progress-bar" style={{ width: `${progress}%` }} />

        {/* ãƒãƒ£ãƒ—ã‚¿ãƒ¼ãƒãƒ¼ã‚«ãƒ¼ */}
        {chapters.map((chapter, index) => (
          <div
            key={index}
            className="chapter-marker"
            style={{ left: `${(chapter.time / duration) * 100}%` }}
            title={chapter.title}
          />
        ))}

        {/* ã‚·ãƒ¼ã‚¯ãƒãƒ³ãƒ‰ãƒ« */}
        <div
          className="seek-handle"
          style={{ left: `${progress}%` }}
          onMouseDown={handleMouseDown}
        />
      </div>

      {/* ãƒ›ãƒãƒ¼æ™‚ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— */}
      {hoverTime !== null && (
        <div className="seek-tooltip" style={{ left: `${(hoverTime / duration) * 100}%` }}>
          {formatTime(hoverTime)}
        </div>
      )}
    </div>
  );
};
```

### 5.3 æ™‚é–“è¡¨ç¤º

```typescript
const TimeDisplay: React.FC<{
  currentTime: number;
  duration: number;
}> = ({ currentTime, duration }) => {
  return (
    <div className="time-display">
      <span className="current-time">{formatTime(currentTime)}</span>
      <span className="separator">/</span>
      <span className="duration">{formatTime(duration)}</span>
    </div>
  );
};

const formatTime = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
};
```

### 5.4 éŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«

```typescript
const VolumeControl: React.FC<{
  volume: number;
  muted: boolean;
  onVolumeChange: (volume: number) => void;
  onMuteToggle: () => void;
}> = ({ volume, muted, onVolumeChange, onMuteToggle }) => {
  const [showSlider, setShowSlider] = useState(false);

  const getVolumeIcon = () => {
    if (muted || volume === 0) return <VolumeXIcon size={20} />;
    if (volume < 0.5) return <Volume1Icon size={20} />;
    return <Volume2Icon size={20} />;
  };

  return (
    <div
      className="volume-control"
      onMouseEnter={() => setShowSlider(true)}
      onMouseLeave={() => setShowSlider(false)}
    >
      <button
        className="volume-button"
        onClick={onMuteToggle}
        aria-label={muted ? 'ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤' : 'ãƒŸãƒ¥ãƒ¼ãƒˆ'}
      >
        {getVolumeIcon()}
      </button>

      {showSlider && (
        <div className="volume-slider-container">
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={muted ? 0 : volume}
            onChange={(e) => onVolumeChange(parseFloat(e.target.value))}
            className="volume-slider"
            aria-label="éŸ³é‡"
          />
        </div>
      )}
    </div>
  );
};
```

### 5.5 å†ç”Ÿé€Ÿåº¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«

```typescript
const PlaybackRateControl: React.FC<{
  playbackRate: number;
  onPlaybackRateChange: (rate: number) => void;
}> = ({ playbackRate, onPlaybackRateChange }) => {
  const [showMenu, setShowMenu] = useState(false);

  const rates = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0];

  return (
    <div className="playback-rate-control">
      <button
        className="rate-button"
        onClick={() => setShowMenu(!showMenu)}
        aria-label="å†ç”Ÿé€Ÿåº¦"
      >
        {playbackRate}x
      </button>

      {showMenu && (
        <div className="rate-menu">
          {rates.map(rate => (
            <button
              key={rate}
              className={`rate-option ${rate === playbackRate ? 'active' : ''}`}
              onClick={() => {
                onPlaybackRateChange(rate);
                setShowMenu(false);
              }}
            >
              {rate}x {rate === 1.0 && '(æ¨™æº–)'}
            </button>
          ))}
        </div>
      )}
    </div>
  );
};
```

---

## 6. å­—å¹•æ©Ÿèƒ½

### 6.1 å­—å¹•ãƒ‘ãƒ¼ã‚µãƒ¼

#### 6.1.1 SRTå½¢å¼

```typescript
interface SubtitleCue {
  id: number;
  startTime: number;  // ç§’
  endTime: number;    // ç§’
  text: string;
}

const parseSRT = (content: string): SubtitleCue[] => {
  const cues: SubtitleCue[] = [];
  const blocks = content.trim().split(/\n\n+/);

  for (const block of blocks) {
    const lines = block.split('\n');
    if (lines.length < 3) continue;

    const id = parseInt(lines[0]);
    const timeMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);

    if (!timeMatch) continue;

    const startTime =
      parseInt(timeMatch[1]) * 3600 +
      parseInt(timeMatch[2]) * 60 +
      parseInt(timeMatch[3]) +
      parseInt(timeMatch[4]) / 1000;

    const endTime =
      parseInt(timeMatch[5]) * 3600 +
      parseInt(timeMatch[6]) * 60 +
      parseInt(timeMatch[7]) +
      parseInt(timeMatch[8]) / 1000;

    const text = lines.slice(2).join('\n');

    cues.push({ id, startTime, endTime, text });
  }

  return cues;
};
```

#### 6.1.2 WebVTTå½¢å¼

```typescript
const parseVTT = (content: string): SubtitleCue[] => {
  const cues: SubtitleCue[] = [];
  const lines = content.split('\n');

  let currentCue: Partial<SubtitleCue> | null = null;
  let id = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // WEBVTT ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (line.startsWith('WEBVTT')) continue;
    if (line.startsWith('NOTE')) continue;

    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¡Œ
    const timeMatch = line.match(/(\d{2}):(\d{2}):(\d{2})\.(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})\.(\d{3})/);

    if (timeMatch) {
      if (currentCue && currentCue.text) {
        cues.push(currentCue as SubtitleCue);
      }

      const startTime =
        parseInt(timeMatch[1]) * 3600 +
        parseInt(timeMatch[2]) * 60 +
        parseInt(timeMatch[3]) +
        parseInt(timeMatch[4]) / 1000;

      const endTime =
        parseInt(timeMatch[5]) * 3600 +
        parseInt(timeMatch[6]) * 60 +
        parseInt(timeMatch[7]) +
        parseInt(timeMatch[8]) / 1000;

      currentCue = { id: id++, startTime, endTime, text: '' };
    } else if (line && currentCue) {
      // ãƒ†ã‚­ã‚¹ãƒˆè¡Œ
      currentCue.text = currentCue.text ? `${currentCue.text}\n${line}` : line;
    }
  }

  // æœ€å¾Œã®ã‚­ãƒ¥ãƒ¼
  if (currentCue && currentCue.text) {
    cues.push(currentCue as SubtitleCue);
  }

  return cues;
};
```

### 6.2 å­—å¹•è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
const SubtitleDisplay: React.FC<{
  cues: SubtitleCue[];
  currentTime: number;
  enabled: boolean;
  fontSize: number;
  position: 'top' | 'bottom';
  backgroundColor: string;
  textColor: string;
}> = ({ cues, currentTime, enabled, fontSize, position, backgroundColor, textColor }) => {
  const [currentCue, setCurrentCue] = useState<SubtitleCue | null>(null);

  useEffect(() => {
    if (!enabled) {
      setCurrentCue(null);
      return;
    }

    // ç¾åœ¨æ™‚åˆ»ã«å¯¾å¿œã™ã‚‹å­—å¹•ã‚’æ¤œç´¢
    const cue = cues.find(c =>
      currentTime >= c.startTime && currentTime <= c.endTime
    );

    setCurrentCue(cue || null);
  }, [currentTime, cues, enabled]);

  if (!currentCue) return null;

  return (
    <div
      className={`subtitle-display ${position}`}
      style={{
        fontSize: `${fontSize}px`,
        backgroundColor,
        color: textColor,
      }}
    >
      {currentCue.text.split('\n').map((line, index) => (
        <div key={index} className="subtitle-line">
          {line}
        </div>
      ))}
    </div>
  );
};
```

### 6.3 å­—å¹•é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼

```typescript
const SubtitleMenu: React.FC<{
  tracks: SubtitleTrack[];
  currentTrack: number | null;
  onTrackSelect: (trackId: number | null) => void;
  fontSize: number;
  onFontSizeChange: (size: number) => void;
}> = ({ tracks, currentTrack, onTrackSelect, fontSize, onFontSizeChange }) => {
  const [showMenu, setShowMenu] = useState(false);

  return (
    <div className="subtitle-menu">
      <button
        className="subtitle-button"
        onClick={() => setShowMenu(!showMenu)}
        aria-label="å­—å¹•è¨­å®š"
      >
        <SubtitlesIcon size={20} />
      </button>

      {showMenu && (
        <div className="subtitle-dropdown">
          <div className="menu-section">
            <h4>å­—å¹•ãƒˆãƒ©ãƒƒã‚¯</h4>
            <button
              className={`track-option ${currentTrack === null ? 'active' : ''}`}
              onClick={() => {
                onTrackSelect(null);
                setShowMenu(false);
              }}
            >
              å­—å¹•ãªã—
            </button>
            {tracks.map(track => (
              <button
                key={track.id}
                className={`track-option ${currentTrack === track.id ? 'active' : ''}`}
                onClick={() => {
                  onTrackSelect(track.id);
                  setShowMenu(false);
                }}
              >
                {track.label} {track.language && `(${track.language})`}
                {track.isEmbedded && <span className="badge">åŸ‹è¾¼</span>}
              </button>
            ))}
          </div>

          <div className="menu-section">
            <h4>ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º</h4>
            <input
              type="range"
              min="12"
              max="48"
              value={fontSize}
              onChange={(e) => onFontSizeChange(parseInt(e.target.value))}
            />
            <span>{fontSize}px</span>
          </div>
        </div>
      )}
    </div>
  );
};
```

### 6.4 å­—å¹•èª­ã¿è¾¼ã¿

```typescript
const useSubtitles = (video: VideoInfo) => {
  const [tracks, setTracks] = useState<SubtitleTrack[]>([]);
  const [currentTrack, setCurrentTrack] = useState<number | null>(null);
  const [cues, setCues] = useState<SubtitleCue[]>([]);

  useEffect(() => {
    setTracks(video.subtitleTracks);
  }, [video]);

  const loadSubtitleTrack = async (trackId: number) => {
    const track = tracks.find(t => t.id === trackId);
    if (!track) return;

    try {
      let content: string;

      if (track.isEmbedded) {
        // åŸ‹ã‚è¾¼ã¿å­—å¹•ã®æŠ½å‡ºï¼ˆffmpegã§å¤‰æ›ï¼‰
        content = await window.electronAPI.extractEmbeddedSubtitle(
          video.path,
          trackId
        );
      } else if (track.path) {
        // å¤–éƒ¨å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        content = await window.electronAPI.readFile(track.path, { encoding: 'utf8' });
      } else {
        return;
      }

      // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¿œã˜ã¦ãƒ‘ãƒ¼ã‚¹
      const parsedCues = track.format === 'vtt'
        ? parseVTT(content)
        : parseSRT(content);

      setCues(parsedCues);
      setCurrentTrack(trackId);
    } catch (error) {
      console.error('Failed to load subtitle:', error);
    }
  };

  const selectTrack = (trackId: number | null) => {
    if (trackId === null) {
      setCurrentTrack(null);
      setCues([]);
    } else {
      loadSubtitleTrack(trackId);
    }
  };

  return {
    tracks,
    currentTrack,
    cues,
    selectTrack,
  };
};
```

---

## 7. ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆæ©Ÿèƒ½

### 7.1 ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆç®¡ç†

```typescript
interface Playlist {
  id: string;
  name: string;
  videos: VideoInfo[];
  currentIndex: number;
  shuffle: boolean;
  repeat: 'none' | 'one' | 'all';
}

const usePlaylist = (initialVideos: VideoInfo[]) => {
  const [playlist, setPlaylist] = useState<Playlist>({
    id: generateId(),
    name: 'Default Playlist',
    videos: initialVideos,
    currentIndex: 0,
    shuffle: false,
    repeat: 'none',
  });

  const [playbackHistory, setPlaybackHistory] = useState<number[]>([]);

  // ç¾åœ¨ã®å‹•ç”»
  const currentVideo = playlist.videos[playlist.currentIndex];

  // æ¬¡ã®å‹•ç”»ã¸
  const next = useCallback(() => {
    const { videos, currentIndex, shuffle, repeat } = playlist;

    if (shuffle) {
      // ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã¯ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠï¼ˆå±¥æ­´ã‚’é¿ã‘ã‚‹ï¼‰
      const availableIndices = videos
        .map((_, i) => i)
        .filter(i => !playbackHistory.includes(i));

      if (availableIndices.length === 0) {
        // ã™ã¹ã¦å†ç”Ÿæ¸ˆã¿ã®å ´åˆ
        if (repeat === 'all') {
          setPlaybackHistory([]);
          const randomIndex = Math.floor(Math.random() * videos.length);
          setPlaylist(prev => ({ ...prev, currentIndex: randomIndex }));
        }
        return;
      }

      const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
      setPlaybackHistory(prev => [...prev, randomIndex]);
      setPlaylist(prev => ({ ...prev, currentIndex: randomIndex }));
    } else {
      // é€šå¸¸å†ç”Ÿ
      if (currentIndex < videos.length - 1) {
        setPlaylist(prev => ({ ...prev, currentIndex: currentIndex + 1 }));
      } else if (repeat === 'all') {
        setPlaylist(prev => ({ ...prev, currentIndex: 0 }));
      }
    }
  }, [playlist, playbackHistory]);

  // å‰ã®å‹•ç”»ã¸
  const previous = useCallback(() => {
    const { currentIndex, shuffle, repeat } = playlist;

    if (shuffle && playbackHistory.length > 0) {
      // ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã¯å±¥æ­´ã‹ã‚‰æˆ»ã‚‹
      const prevIndex = playbackHistory[playbackHistory.length - 1];
      setPlaybackHistory(prev => prev.slice(0, -1));
      setPlaylist(prev => ({ ...prev, currentIndex: prevIndex }));
    } else {
      // é€šå¸¸å†ç”Ÿ
      if (currentIndex > 0) {
        setPlaylist(prev => ({ ...prev, currentIndex: currentIndex - 1 }));
      } else if (repeat === 'all') {
        setPlaylist(prev => ({ ...prev, currentIndex: playlist.videos.length - 1 }));
      }
    }
  }, [playlist, playbackHistory]);

  // ç‰¹å®šã®å‹•ç”»ã‚’é¸æŠ
  const selectVideo = useCallback((index: number) => {
    if (index >= 0 && index < playlist.videos.length) {
      setPlaylist(prev => ({ ...prev, currentIndex: index }));
      setPlaybackHistory([]);
    }
  }, [playlist.videos.length]);

  // ã‚·ãƒ£ãƒƒãƒ•ãƒ«åˆ‡æ›¿
  const toggleShuffle = useCallback(() => {
    setPlaylist(prev => ({ ...prev, shuffle: !prev.shuffle }));
    setPlaybackHistory([]);
  }, []);

  // ãƒªãƒ”ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
  const cycleRepeat = useCallback(() => {
    setPlaylist(prev => {
      const modes: Array<'none' | 'one' | 'all'> = ['none', 'one', 'all'];
      const currentIndex = modes.indexOf(prev.repeat);
      const nextMode = modes[(currentIndex + 1) % modes.length];
      return { ...prev, repeat: nextMode };
    });
  }, []);

  // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆã«å‹•ç”»è¿½åŠ 
  const addVideo = useCallback((video: VideoInfo) => {
    setPlaylist(prev => ({
      ...prev,
      videos: [...prev.videos, video],
    }));
  }, []);

  // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆã‹ã‚‰å‹•ç”»å‰Šé™¤
  const removeVideo = useCallback((index: number) => {
    setPlaylist(prev => {
      const newVideos = prev.videos.filter((_, i) => i !== index);
      const newIndex = index <= prev.currentIndex
        ? Math.max(0, prev.currentIndex - 1)
        : prev.currentIndex;

      return {
        ...prev,
        videos: newVideos,
        currentIndex: newIndex,
      };
    });
  }, []);

  return {
    playlist,
    currentVideo,
    next,
    previous,
    selectVideo,
    toggleShuffle,
    cycleRepeat,
    addVideo,
    removeVideo,
    hasNext: playlist.currentIndex < playlist.videos.length - 1 || playlist.repeat === 'all',
    hasPrevious: playlist.currentIndex > 0 || playlist.repeat === 'all',
  };
};
```

### 7.2 ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆãƒ‘ãƒãƒ«UI

```typescript
const PlaylistPanel: React.FC<{
  playlist: Playlist;
  currentIndex: number;
  onVideoSelect: (index: number) => void;
  onVideoRemove: (index: number) => void;
  onShuffle: () => void;
  onRepeat: () => void;
  isOpen: boolean;
  onClose: () => void;
}> = ({
  playlist,
  currentIndex,
  onVideoSelect,
  onVideoRemove,
  onShuffle,
  onRepeat,
  isOpen,
  onClose
}) => {
  if (!isOpen) return null;

  const getRepeatIcon = () => {
    switch (playlist.repeat) {
      case 'one': return <Repeat1Icon size={20} />;
      case 'all': return <RepeatIcon size={20} />;
      default: return <RepeatIcon size={20} className="inactive" />;
    }
  };

  return (
    <div className="playlist-panel">
      <div className="panel-header">
        <h3>ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ ({playlist.videos.length}ä»¶)</h3>
        <div className="header-controls">
          <button
            className={`control-button ${playlist.shuffle ? 'active' : ''}`}
            onClick={onShuffle}
            title="ã‚·ãƒ£ãƒƒãƒ•ãƒ«"
          >
            <ShuffleIcon size={20} />
          </button>
          <button
            className={`control-button ${playlist.repeat !== 'none' ? 'active' : ''}`}
            onClick={onRepeat}
            title="ãƒªãƒ”ãƒ¼ãƒˆ"
          >
            {getRepeatIcon()}
          </button>
          <button onClick={onClose}>
            <XIcon size={20} />
          </button>
        </div>
      </div>

      <div className="playlist-items">
        {playlist.videos.map((video, index) => (
          <PlaylistItem
            key={video.path}
            video={video}
            index={index}
            isPlaying={index === currentIndex}
            onSelect={() => onVideoSelect(index)}
            onRemove={() => onVideoRemove(index)}
          />
        ))}
      </div>
    </div>
  );
};

const PlaylistItem: React.FC<{
  video: VideoInfo;
  index: number;
  isPlaying: boolean;
  onSelect: () => void;
  onRemove: () => void;
}> = ({ video, index, isPlaying, onSelect, onRemove }) => {
  return (
    <div
      className={`playlist-item ${isPlaying ? 'playing' : ''}`}
      onClick={onSelect}
    >
      <div className="item-thumbnail">
        {video.thumbnailPath ? (
          <img src={`file://${video.thumbnailPath}`} alt={video.name} />
        ) : (
          <div className="thumbnail-placeholder">
            <VideoIcon size={32} />
          </div>
        )}
        {isPlaying && (
          <div className="playing-indicator">
            <PlayIcon size={16} />
          </div>
        )}
      </div>

      <div className="item-info">
        <div className="item-title">{video.name}</div>
        <div className="item-meta">
          <span>{formatTime(video.duration)}</span>
          <span className="separator">â€¢</span>
          <span>{video.width}x{video.height}</span>
        </div>
      </div>

      <button
        className="item-remove"
        onClick={(e) => {
          e.stopPropagation();
          onRemove();
        }}
        aria-label="å‰Šé™¤"
      >
        <TrashIcon size={16} />
      </button>
    </div>
  );
};
```

---

## é«˜åº¦ãªæ©Ÿèƒ½ãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œãƒ»çµ±åˆ

---

## 9. é«˜åº¦ãªæ©Ÿèƒ½

### 9.1 ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ©Ÿèƒ½

```typescript
const useSnapshot = (videoRef: RefObject<HTMLVideoElement>) => {
  const takeSnapshot = useCallback(async (): Promise<string | null> => {
    const video = videoRef.current;
    if (!video) return null;

    try {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      // ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // PNG ã¨ã—ã¦ä¿å­˜
      const dataUrl = canvas.toDataURL('image/png');

      // ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã§ä¿å­˜
      const timestamp = Date.now();
      const filename = `snapshot_${timestamp}.png`;
      const savePath = await window.electronAPI.saveSnapshot(dataUrl, filename);

      return savePath;

    } catch (error) {
      console.error('Failed to take snapshot:', error);
      return null;
    }
  }, [videoRef]);

  return { takeSnapshot };
};
```

**ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹:**

```typescript
// main/ipc/handlers.ts
ipcMain.handle('save-snapshot', async (event, dataUrl: string, filename: string) => {
  const picturesPath = app.getPath('pictures');
  const snapshotsDir = path.join(picturesPath, 'GentleViewer', 'Snapshots');

  await fs.promises.mkdir(snapshotsDir, { recursive: true });

  const savePath = path.join(snapshotsDir, filename);

  // Data URLã‚’ãƒãƒƒãƒ•ã‚¡ã«å¤‰æ›
  const base64Data = dataUrl.replace(/^data:image\/png;base64,/, '');
  const buffer = Buffer.from(base64Data, 'base64');

  await fs.promises.writeFile(savePath, buffer);

  return savePath;
});
```

### 9.2 ãƒãƒ£ãƒ—ã‚¿ãƒ¼æ©Ÿèƒ½

```typescript
interface Chapter {
  id: string;
  time: number;      // ç§’
  title: string;
  description?: string;
}

const useChapters = (fileId: number) => {
  const [chapters, setChapters] = useState<Chapter[]>([]);

  // ãƒãƒ£ãƒ—ã‚¿ãƒ¼èª­ã¿è¾¼ã¿
  useEffect(() => {
    const loadChapters = async () => {
      const saved = await window.electronAPI.getChapters(fileId);
      setChapters(saved || []);
    };
    loadChapters();
  }, [fileId]);

  // ãƒãƒ£ãƒ—ã‚¿ãƒ¼è¿½åŠ 
  const addChapter = useCallback(async (time: number, title: string) => {
    const newChapter: Chapter = {
      id: generateId(),
      time,
      title,
    };

    const updated = [...chapters, newChapter].sort((a, b) => a.time - b.time);
    setChapters(updated);

    await window.electronAPI.saveChapters(fileId, updated);
  }, [fileId, chapters]);

  // ãƒãƒ£ãƒ—ã‚¿ãƒ¼å‰Šé™¤
  const removeChapter = useCallback(async (chapterId: string) => {
    const updated = chapters.filter(c => c.id !== chapterId);
    setChapters(updated);

    await window.electronAPI.saveChapters(fileId, updated);
  }, [fileId, chapters]);

  // ãƒãƒ£ãƒ—ã‚¿ãƒ¼ç·¨é›†
  const updateChapter = useCallback(async (
    chapterId: string,
    updates: Partial<Chapter>
  ) => {
    const updated = chapters.map(c =>
      c.id === chapterId ? { ...c, ...updates } : c
    );
    setChapters(updated);

    await window.electronAPI.saveChapters(fileId, updated);
  }, [fileId, chapters]);

  return {
    chapters,
    addChapter,
    removeChapter,
    updateChapter,
  };
};
```

**ãƒãƒ£ãƒ—ã‚¿ãƒ¼ãƒªã‚¹ãƒˆè¡¨ç¤º:**

```typescript
const ChapterList: React.FC<{
  chapters: Chapter[];
  currentTime: number;
  onSeek: (time: number) => void;
  onEdit: (chapter: Chapter) => void;
  onDelete: (chapterId: string) => void;
}> = ({ chapters, currentTime, onSeek, onEdit, onDelete }) => {
  return (
    <div className="chapter-list">
      <div className="chapter-list-header">
        <h4>ãƒãƒ£ãƒ—ã‚¿ãƒ¼ ({chapters.length})</h4>
      </div>

      <div className="chapter-items">
        {chapters.map(chapter => {
          const isActive =
            currentTime >= chapter.time &&
            (chapters[chapters.indexOf(chapter) + 1]?.time > currentTime ||
             !chapters[chapters.indexOf(chapter) + 1]);

          return (
            <div
              key={chapter.id}
              className={`chapter-item ${isActive ? 'active' : ''}`}
              onClick={() => onSeek(chapter.time)}
            >
              <div className="chapter-time">
                {formatTime(chapter.time)}
              </div>
              <div className="chapter-title">
                {chapter.title}
              </div>
              <div className="chapter-actions">
                <button onClick={(e) => {
                  e.stopPropagation();
                  onEdit(chapter);
                }}>
                  <EditIcon size={16} />
                </button>
                <button onClick={(e) => {
                  e.stopPropagation();
                  onDelete(chapter.id);
                }}>
                  <TrashIcon size={16} />
                </button>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

### 9.3 ãƒ”ã‚¯ãƒãƒ£ãƒ¼ã‚¤ãƒ³ãƒ”ã‚¯ãƒãƒ£ãƒ¼

```typescript
const usePictureInPicture = (videoRef: RefObject<HTMLVideoElement>) => {
  const [isPiP, setIsPiP] = useState(false);

  const enterPiP = useCallback(async () => {
    const video = videoRef.current;
    if (!video || !document.pictureInPictureEnabled) return;

    try {
      await video.requestPictureInPicture();
      setIsPiP(true);
    } catch (error) {
      console.error('Failed to enter PiP:', error);
    }
  }, [videoRef]);

  const exitPiP = useCallback(async () => {
    if (document.pictureInPictureElement) {
      await document.exitPictureInPicture();
      setIsPiP(false);
    }
  }, []);

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleEnterPiP = () => setIsPiP(true);
    const handleLeavePiP = () => setIsPiP(false);

    video.addEventListener('enterpictureinpicture', handleEnterPiP);
    video.addEventListener('leavepictureinpicture', handleLeavePiP);

    return () => {
      video.removeEventListener('enterpictureinpicture', handleEnterPiP);
      video.removeEventListener('leavepictureinpicture', handleLeavePiP);
    };
  }, [videoRef]);

  return { isPiP, enterPiP, exitPiP };
};
```

### 9.4 A-Bãƒªãƒ”ãƒ¼ãƒˆ

```typescript
interface ABRepeat {
  pointA: number | null;
  pointB: number | null;
}

const useABRepeat = (
  videoRef: RefObject<HTMLVideoElement>,
  currentTime: number
) => {
  const [abRepeat, setABRepeat] = useState<ABRepeat>({
    pointA: null,
    pointB: null,
  });

  // Aåœ°ç‚¹è¨­å®š
  const setPointA = useCallback(() => {
    setABRepeat({ pointA: currentTime, pointB: null });
  }, [currentTime]);

  // Båœ°ç‚¹è¨­å®š
  const setPointB = useCallback(() => {
    if (abRepeat.pointA === null) return;

    if (currentTime > abRepeat.pointA) {
      setABRepeat(prev => ({ ...prev, pointB: currentTime }));
    }
  }, [currentTime, abRepeat.pointA]);

  // ã‚¯ãƒªã‚¢
  const clearABRepeat = useCallback(() => {
    setABRepeat({ pointA: null, pointB: null });
  }, []);

  // ãƒªãƒ”ãƒ¼ãƒˆå‡¦ç†
  useEffect(() => {
    const video = videoRef.current;
    if (!video || abRepeat.pointA === null || abRepeat.pointB === null) return;

    if (currentTime >= abRepeat.pointB) {
      video.currentTime = abRepeat.pointA;
    }
  }, [currentTime, abRepeat, videoRef]);

  return {
    abRepeat,
    setPointA,
    setPointB,
    clearABRepeat,
  };
};
```

---

## 10. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ»ãƒã‚¦ã‚¹æ“ä½œ

### 10.1 ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ

```typescript
const useVideoKeyboard = (
  videoRef: RefObject<HTMLVideoElement>,
  actions: VideoActions
) => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const video = videoRef.current;
      if (!video) return;

      switch (e.key) {
        // å†ç”Ÿ/ä¸€æ™‚åœæ­¢
        case ' ':
        case 'k':
          e.preventDefault();
          actions.togglePlay();
          break;

        // ã‚·ãƒ¼ã‚¯
        case 'ArrowLeft':
          e.preventDefault();
          if (e.shiftKey) {
            actions.seek(video.currentTime - 10); // 10ç§’æˆ»ã‚‹
          } else {
            actions.seek(video.currentTime - 5);  // 5ç§’æˆ»ã‚‹
          }
          break;

        case 'ArrowRight':
          e.preventDefault();
          if (e.shiftKey) {
            actions.seek(video.currentTime + 10); // 10ç§’é€²ã‚€
          } else {
            actions.seek(video.currentTime + 5);  // 5ç§’é€²ã‚€
          }
          break;

        case 'j':
          e.preventDefault();
          actions.seek(video.currentTime - 10);
          break;

        case 'l':
          e.preventDefault();
          actions.seek(video.currentTime + 10);
          break;

        case 'Home':
          e.preventDefault();
          actions.seek(0);
          break;

        case 'End':
          e.preventDefault();
          actions.seek(video.duration);
          break;

        // éŸ³é‡
        case 'ArrowUp':
          e.preventDefault();
          actions.changeVolume(Math.min(video.volume + 0.05, 1));
          break;

        case 'ArrowDown':
          e.preventDefault();
          actions.changeVolume(Math.max(video.volume - 0.05, 0));
          break;

        case 'm':
          e.preventDefault();
          actions.toggleMute();
          break;

        // å†ç”Ÿé€Ÿåº¦
        case '<':
        case ',':
          e.preventDefault();
          actions.changePlaybackRate(Math.max(video.playbackRate - 0.25, 0.25));
          break;

        case '>':
        case '.':
          e.preventDefault();
          actions.changePlaybackRate(Math.min(video.playbackRate + 0.25, 2.0));
          break;

        case '0':
          e.preventDefault();
          actions.changePlaybackRate(1.0);
          break;

        // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ
        case 'n':
        case 'N':
          e.preventDefault();
          actions.nextVideo();
          break;

        case 'p':
        case 'P':
          e.preventDefault();
          actions.previousVideo();
          break;

        // å…¨ç”»é¢
        case 'f':
        case 'F11':
          e.preventDefault();
          actions.toggleFullscreen();
          break;

        // ãƒ”ã‚¯ãƒãƒ£ãƒ¼ã‚¤ãƒ³ãƒ”ã‚¯ãƒãƒ£ãƒ¼
        case 'i':
          e.preventDefault();
          actions.togglePiP();
          break;

        // å­—å¹•
        case 'c':
          e.preventDefault();
          actions.toggleSubtitles();
          break;

        // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
        case 's':
          e.preventDefault();
          actions.takeSnapshot();
          break;

        // ãƒãƒ£ãƒ—ã‚¿ãƒ¼
        case 'b':
          e.preventDefault();
          actions.addChapterMark();
          break;

        // A-Bãƒªãƒ”ãƒ¼ãƒˆ
        case 'a':
          e.preventDefault();
          actions.setPointA();
          break;

        case 'Shift + A':
          if (e.shiftKey && e.key === 'A') {
            e.preventDefault();
            actions.setPointB();
          }
          break;

        // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆãƒ‘ãƒãƒ«
        case 'l':
          if (e.ctrlKey) {
            e.preventDefault();
            actions.togglePlaylist();
          }
          break;

        // è¨­å®š
        case ',':
          if (e.ctrlKey) {
            e.preventDefault();
            actions.openSettings();
          }
          break;

        // é–‰ã˜ã‚‹
        case 'Escape':
          if (actions.isFullscreen) {
            actions.exitFullscreen();
          } else {
            actions.closeViewer();
          }
          break;

        case 'q':
          e.preventDefault();
          actions.closeViewer();
          break;

        // æ•°å­—ã‚­ãƒ¼: ç‰¹å®šä½ç½®ã¸ã‚·ãƒ¼ã‚¯
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          e.preventDefault();
          const percent = parseInt(e.key) * 10;
          actions.seek((video.duration * percent) / 100);
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [videoRef, actions]);
};
```

### 10.2 ãƒã‚¦ã‚¹æ“ä½œ

```typescript
const useVideoMouse = (
  containerRef: RefObject<HTMLDivElement>,
  videoRef: RefObject<HTMLVideoElement>,
  actions: VideoActions
) => {
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // ã‚¯ãƒªãƒƒã‚¯ã§å†ç”Ÿ/ä¸€æ™‚åœæ­¢
    const handleClick = (e: MouseEvent) => {
      // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ä¸Šã§ã®ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–
      if ((e.target as HTMLElement).closest('.controls-bar')) {
        return;
      }

      actions.togglePlay();
    };

    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å…¨ç”»é¢åˆ‡æ›¿
    const handleDoubleClick = (e: MouseEvent) => {
      e.preventDefault();
      actions.toggleFullscreen();
    };

    // å³ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
    const handleContextMenu = (e: MouseEvent) => {
      e.preventDefault();
      actions.showContextMenu(e.clientX, e.clientY);
    };

    // ãƒ›ã‚¤ãƒ¼ãƒ«ã§éŸ³é‡èª¿æ•´
    const handleWheel = (e: WheelEvent) => {
      const video = videoRef.current;
      if (!video) return;

      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.05 : 0.05;
      actions.changeVolume(Math.max(0, Math.min(1, video.volume + delta)));
    };

    container.addEventListener('click', handleClick);
    container.addEventListener('dblclick', handleDoubleClick);
    container.addEventListener('contextmenu', handleContextMenu);
    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('click', handleClick);
      container.removeEventListener('dblclick', handleDoubleClick);
      container.removeEventListener('contextmenu', handleContextMenu);
      container.removeEventListener('wheel', handleWheel);
    };
  }, [containerRef, videoRef, actions]);
};
```

---

## 11. ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼

```typescript
const VideoContextMenu: React.FC<{
  x: number;
  y: number;
  onClose: () => void;
  actions: VideoActions;
  currentTime: number;
}> = ({ x, y, onClose, actions, currentTime }) => {
  const menuItems = [
    {
      label: 'å†ç”Ÿ/ä¸€æ™‚åœæ­¢',
      icon: <PlayIcon />,
      onClick: actions.togglePlay,
      shortcut: 'Space',
    },
    { separator: true },
    {
      label: '10ç§’æˆ»ã‚‹',
      icon: <Rewind10Icon />,
      onClick: () => actions.seek(currentTime - 10),
      shortcut: 'J',
    },
    {
      label: '10ç§’é€²ã‚€',
      icon: <Forward10Icon />,
      onClick: () => actions.seek(currentTime + 10),
      shortcut: 'L',
    },
    { separator: true },
    {
      label: 'å†ç”Ÿé€Ÿåº¦',
      icon: <SpeedIcon />,
      submenu: [
        { label: '0.25x', onClick: () => actions.changePlaybackRate(0.25) },
        { label: '0.5x', onClick: () => actions.changePlaybackRate(0.5) },
        { label: '0.75x', onClick: () => actions.changePlaybackRate(0.75) },
        { label: '1.0x (æ¨™æº–)', onClick: () => actions.changePlaybackRate(1.0) },
        { label: '1.25x', onClick: () => actions.changePlaybackRate(1.25) },
        { label: '1.5x', onClick: () => actions.changePlaybackRate(1.5) },
        { label: '2.0x', onClick: () => actions.changePlaybackRate(2.0) },
      ],
    },
    {
      label: 'å­—å¹•',
      icon: <SubtitlesIcon />,
      onClick: actions.toggleSubtitles,
      shortcut: 'C',
    },
    { separator: true },
    {
      label: 'ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ',
      icon: <CameraIcon />,
      onClick: actions.takeSnapshot,
      shortcut: 'S',
    },
    {
      label: 'ãƒãƒ£ãƒ—ã‚¿ãƒ¼ãƒãƒ¼ã‚¯è¿½åŠ ',
      icon: <BookmarkIcon />,
      onClick: actions.addChapterMark,
      shortcut: 'B',
    },
    { separator: true },
    {
      label: 'A-Bãƒªãƒ”ãƒ¼ãƒˆ',
      icon: <RepeatIcon />,
      submenu: [
        { label: 'Aåœ°ç‚¹ã‚’è¨­å®š', onClick: actions.setPointA, shortcut: 'A' },
        { label: 'Båœ°ç‚¹ã‚’è¨­å®š', onClick: actions.setPointB, shortcut: 'Shift+A' },
        { label: 'ã‚¯ãƒªã‚¢', onClick: actions.clearABRepeat },
      ],
    },
    { separator: true },
    {
      label: 'ãƒ”ã‚¯ãƒãƒ£ãƒ¼ã‚¤ãƒ³ãƒ”ã‚¯ãƒãƒ£ãƒ¼',
      icon: <PipIcon />,
      onClick: actions.togglePiP,
      shortcut: 'I',
    },
    {
      label: 'å…¨ç”»é¢',
      icon: <FullscreenIcon />,
      onClick: actions.toggleFullscreen,
      shortcut: 'F',
    },
    { separator: true },
    {
      label: 'ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã§è¡¨ç¤º',
      icon: <FolderIcon />,
      onClick: actions.showInExplorer,
    },
    {
      label: 'è¨­å®š',
      icon: <SettingsIcon />,
      onClick: actions.openSettings,
      shortcut: 'Ctrl+,',
    },
    { separator: true },
    {
      label: 'ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã‚’é–‰ã˜ã‚‹',
      icon: <CloseIcon />,
      onClick: actions.closeViewer,
      shortcut: 'Q',
    },
  ];

  return (
    <ContextMenu
      x={x}
      y={y}
      items={menuItems}
      onClose={onClose}
    />
  );
};
```

---

## 12. è¨­å®šãƒ‘ãƒãƒ«

```typescript
interface VideoViewerSettings {
  // å†ç”Ÿ
  autoPlay: boolean;
  defaultVolume: number;
  defaultPlaybackRate: number;
  rememberPosition: boolean;

  // å­—å¹•
  defaultSubtitleLanguage: string;
  subtitleFontSize: number;
  subtitleColor: string;
  subtitleBackgroundColor: string;
  subtitleOutline: boolean;

  // UI
  autoHideControls: boolean;
  autoHideDelay: number;
  showThumbnailPreview: boolean;

  // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ
  autoPlayNext: boolean;
  defaultRepeatMode: 'none' | 'one' | 'all';

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
  hardwareAcceleration: boolean;
  preloadAmount: number; // ç§’
}

const DEFAULT_VIDEO_SETTINGS: VideoViewerSettings = {
  autoPlay: false,
  defaultVolume: 1.0,
  defaultPlaybackRate: 1.0,
  rememberPosition: true,
  defaultSubtitleLanguage: 'ja',
  subtitleFontSize: 24,
  subtitleColor: '#ffffff',
  subtitleBackgroundColor: 'rgba(0, 0, 0, 0.7)',
  subtitleOutline: true,
  autoHideControls: true,
  autoHideDelay: 3000,
  showThumbnailPreview: true,
  autoPlayNext: true,
  defaultRepeatMode: 'none',
  hardwareAcceleration: true,
  preloadAmount: 30,
};
```

---

## 13. çµ±åˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 13.1 ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
const VideoViewer: React.FC<{
  videos: VideoInfo[];
  initialIndex?: number;
  onClose: () => void;
}> = ({ videos, initialIndex = 0, onClose }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ
  const {
    playlist,
    currentVideo,
    hasPrevious,
    hasNext,
    next,
    previous,
    goTo,
    toggleShuffle,
    toggleRepeat,
  } = usePlaylist(videos);

  // å‹•ç”»æƒ…å ±
  const [videoInfo, setVideoInfo] = useState<VideoInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // å†ç”ŸçŠ¶æ…‹
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1.0);
  const [muted, setMuted] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1.0);
  const [buffered, setBuffered] = useState<TimeRanges | null>(null);

  // UIçŠ¶æ…‹
  const [showControls, setShowControls] = useState(true);
  const [showPlaylist, setShowPlaylist] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number } | null>(null);
  const [isFullscreen, setIsFullscreen] = useState(false);

  // è¨­å®š
  const [settings, setSettings] = useState<VideoViewerSettings>(DEFAULT_VIDEO_SETTINGS);

  // å­—å¹•
  const {
    subtitles,
    activeCues,
    activeSubtitle,
    setActiveSubtitle,
  } = useSubtitles(currentVideo);

  // è¦–è´å±¥æ­´
  const { history, saveHistory, autoSave } = useWatchHistory(
    currentVideo.id,
    duration
  );

  // ãƒãƒ£ãƒ—ã‚¿ãƒ¼
  const {
    chapters,
    addChapter,
    removeChapter,
    updateChapter,
  } = useChapters(currentVideo.id);

  // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
  const { takeSnapshot } = useSnapshot(videoRef);

  // ãƒ”ã‚¯ãƒãƒ£ãƒ¼ã‚¤ãƒ³ãƒ”ã‚¯ãƒãƒ£ãƒ¼
  const { isPiP, enterPiP, exitPiP } = usePictureInPicture(videoRef);

  // A-Bãƒªãƒ”ãƒ¼ãƒˆ
  const {
    abRepeat,
    setPointA,
    setPointB,
    clearABRepeat,
  } = useABRepeat(videoRef, currentTime);

  // å‹•ç”»èª­ã¿è¾¼ã¿
  useEffect(() => {
    const init = async () => {
      setLoading(true);
      const result = await loadVideo(currentVideo.path);

      if (result.success && result.video) {
        setVideoInfo(result.video);
      } else {
        setError(result.error || 'å‹•ç”»ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      setLoading(false);
    };

    init();
  }, [currentVideo]);

  // è¦–è´å±¥æ­´ã®è‡ªå‹•ä¿å­˜
  useEffect(() => {
    if (settings.rememberPosition && currentTime > 0) {
      autoSave(currentTime);
    }
  }, [currentTime, settings.rememberPosition, autoSave]);

  // å‹•ç”»çµ‚äº†æ™‚ã®å‡¦ç†
  const handleVideoEnded = useCallback(() => {
    if (playlist.repeat === 'one') {
      videoRef.current?.play();
    } else if (settings.autoPlayNext && hasNext) {
      next();
    } else {
      setIsPlaying(false);
    }
  }, [playlist.repeat, settings.autoPlayNext, hasNext, next]);

  // ãƒ“ãƒ¥ãƒ¼ãƒ¯ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  const actions: VideoActions = {
    togglePlay: () => {
      const video = videoRef.current;
      if (!video) return;

      if (isPlaying) {
        video.pause();
      } else {
        video.play();
      }
      setIsPlaying(!isPlaying);
    },

    seek: (time: number) => {
      const video = videoRef.current;
      if (!video) return;
      video.currentTime = Math.max(0, Math.min(time, duration));
    },

    changeVolume: (newVolume: number) => {
      const video = videoRef.current;
      if (!video) return;
      video.volume = Math.max(0, Math.min(1, newVolume));
      setVolume(newVolume);
    },

    toggleMute: () => {
      const video = videoRef.current;
      if (!video) return;
      video.muted = !muted;
      setMuted(!muted);
    },

    changePlaybackRate: (rate: number) => {
      const video = videoRef.current;
      if (!video) return;
      video.playbackRate = rate;
      setPlaybackRate(rate);
    },

    nextVideo: next,
    previousVideo: previous,

    toggleFullscreen: () => {
      if (!document.fullscreenElement) {
        containerRef.current?.requestFullscreen();
        setIsFullscreen(true);
      } else {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    },

    exitFullscreen: () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    },

    toggleSubtitles: () => {
      if (activeSubtitle !== null) {
        setActiveSubtitle(null);
      } else if (subtitles.size > 0) {
        setActiveSubtitle(Array.from(subtitles.keys())[0]);
      }
    },

    takeSnapshot: async () => {
      const path = await takeSnapshot();
      if (path) {
        // æˆåŠŸé€šçŸ¥
        showNotification({
          type: 'success',
          message: `ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ: ${path}`,
        });
      }
    },

    addChapterMark: () => {
      const title = prompt('ãƒãƒ£ãƒ—ã‚¿ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      if (title) {
        addChapter(currentTime, title);
      }
    },

    setPointA: () => setPointA(),
    setPointB: () => setPointB(),
    clearABRepeat: () => clearABRepeat(),

    togglePiP: () => {
      if (isPiP) {
        exitPiP();
      } else {
        enterPiP();
      }
    },

    togglePlaylist: () => setShowPlaylist(!showPlaylist),
    openSettings: () => setShowSettings(true),

    showContextMenu: (x: number, y: number) => {
      setContextMenu({ x, y });
    },

    showInExplorer: () => {
      window.electronAPI.showInExplorer(currentVideo.path);
    },

    closeViewer: () => {
      saveHistory(currentTime);
      onClose();
    },

    isFullscreen,
  };

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ»ãƒã‚¦ã‚¹æ“ä½œ
  useVideoKeyboard(videoRef, actions);
  useVideoMouse(containerRef, videoRef, actions);

  // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®è‡ªå‹•éè¡¨ç¤º
  const { visible: controlsVisible } = useAutoHide({
    enabled: settings.autoHideControls && !isPiP,
    delay: settings.autoHideDelay,
  });

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
  if (loading) {
    return (
      <div className="viewer-loading">
        <Spinner size={64} />
        <p>å‹•ç”»ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</p>
      </div>
    );
  }

  // ã‚¨ãƒ©ãƒ¼
  if (error || !videoInfo) {
    return (
      <div className="viewer-error">
        <AlertTriangleIcon size={64} />
        <h3>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h3>
        <p>{error}</p>
        <button onClick={onClose}>é–‰ã˜ã‚‹</button>
      </div>
    );
  }

  // è¦–è´å±¥æ­´å¾©å¸°
  const [showHistoryResume, setShowHistoryResume] = useState(
    !!history && history.lastPosition > 30 && !history.completed
  );

  return (
    <div
      className="video-viewer"
      ref={containerRef}
      data-fullscreen={isFullscreen}
    >
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      {!isFullscreen && (
        <ViewerHeader
          visible={controlsVisible}
          videoInfo={videoInfo}
          playlistPosition={`${playlist.currentIndex + 1}/${playlist.videos.length}`}
          onPrevious={hasPrevious ? previous : undefined}
          onNext={hasNext ? next : undefined}
          onTogglePlaylist={() => setShowPlaylist(!showPlaylist)}
          onOpenSettings={() => setShowSettings(true)}
          onClose={onClose}
        />
      )}

      {/* å‹•ç”»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ */}
      <div className="video-container">
        <video
          ref={videoRef}
          className="video-element"
          src={`file://${videoInfo.path}`}
          playsInline
          preload="metadata"
          onLoadedMetadata={(e) => setDuration(e.currentTarget.duration)}
          onTimeUpdate={(e) => setCurrentTime(e.currentTarget.currentTime)}
          onProgress={(e) => setBuffered(e.currentTarget.buffered)}
          onEnded={handleVideoEnded}
        />

        {/* å­—å¹•è¡¨ç¤º */}
        {activeCues && (
          <SubtitleDisplay
            cues={activeCues}
            currentTime={currentTime}
            style={{
              fontSize: settings.subtitleFontSize,
              color: settings.subtitleColor,
              backgroundColor: settings.subtitleBackgroundColor,
              fontFamily: 'sans-serif',
              outline: settings.subtitleOutline,
            }}
          />
        )}

        {/* A-Bãƒªãƒ”ãƒ¼ãƒˆè¡¨ç¤º */}
        {(abRepeat.pointA !== null || abRepeat.pointB !== null) && (
          <div className="ab-repeat-indicator">
            A: {abRepeat.pointA !== null ? formatTime(abRepeat.pointA) : '--:--'}
            {' | '}
            B: {abRepeat.pointB !== null ? formatTime(abRepeat.pointB) : '--:--'}
          </div>
        )}
      </div>

      {/* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */}
      <ControlsBar
        visible={controlsVisible && !isPiP}
        isPlaying={isPlaying}
        currentTime={currentTime}
        duration={duration}
        buffered={buffered}
        volume={volume}
        muted={muted}
        playbackRate={playbackRate}
        chapters={chapters}
        hasPrevious={hasPrevious}
        hasNext={hasNext}
        onPlayPause={actions.togglePlay}
        onPrevious={previous}
        onNext={next}
        onSeek={actions.seek}
        onVolumeChange={actions.changeVolume}
        onMuteToggle={actions.toggleMute}
        onPlaybackRateChange={actions.changePlaybackRate}
        onToggleFullscreen={actions.toggleFullscreen}
        onTakeSnapshot={actions.takeSnapshot}
        onAddChapter={actions.addChapterMark}
      />

      {/* ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆãƒ‘ãƒãƒ« */}
      <PlaylistPanel
        playlist={playlist}
        onSelect={goTo}
        onClose={() => setShowPlaylist(false)}
        isOpen={showPlaylist}
      />

      {/* è¨­å®šãƒ‘ãƒãƒ« */}
      {showSettings && (
        <VideoSettingsPanel
          settings={settings}
          onSettingsChange={(newSettings) => {
            setSettings(newSettings);
            setShowSettings(false);
          }}
          onClose={() => setShowSettings(false)}
        />
      )}

      {/* ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
      {contextMenu && (
        <VideoContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          onClose={() => setContextMenu(null)}
          actions={actions}
          currentTime={currentTime}
        />
      )}

      {/* è¦–è´å±¥æ­´å¾©å¸° */}
      {showHistoryResume && history && (
        <WatchHistoryResume
          history={history}
          onResume={() => {
            actions.seek(history.lastPosition);
            setShowHistoryResume(false);
          }}
          onStartOver={() => {
            actions.seek(0);
            setShowHistoryResume(false);
          }}
        />
      )}
    </div>
  );
};

export default VideoViewer;
```

---

## 14. å‹å®šç¾©ã¾ã¨ã‚

```typescript
// types.ts
export interface VideoActions {
  togglePlay: () => void;
  seek: (time: number) => void;
  changeVolume: (volume: number) => void;
  toggleMute: () => void;
  changePlaybackRate: (rate: number) => void;
  nextVideo: () => void;
  previousVideo: () => void;
  toggleFullscreen: () => void;
  exitFullscreen: () => void;
  toggleSubtitles: () => void;
  takeSnapshot: () => Promise<void>;
  addChapterMark: () => void;
  setPointA: () => void;
  setPointB: () => void;
  clearABRepeat: () => void;
  togglePiP: () => void;
  togglePlaylist: () => void;
  openSettings: () => void;
  showContextMenu: (x: number, y: number) => void;
  showInExplorer: () => void;
  closeViewer: () => void;
  isFullscreen: boolean;
}
```

---
